(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.11.1
var AnnotationDisplay, createTree, doc, entities,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

doc = {
  "text": "@B_brewer2 was gonna be early like 9ish cuz he didn't wanna stay out late and I have a doc apt tomorrow. But we'll callB B_brewer2 Peoples champion. #CMU Instagram @b_brewer2 Mount Pleasant / Dirty Mitten \n\n",
  "entities": {
    "Mentions:name": [
      {
        "indices": [119, 120],
        "annotationID": 2,
        "org_lookup_count": 0,
        "disclaimer_count": 0,
        "first_plural_count": 0,
        "first_singular_count": 0,
        "loc_lookup_count": 0,
        "occ_lookup_count": 0,
        "official_count": 0,
        "per_lookup_count": 0,
        "preposition_place_count": 0,
        "token_count": 1,
        "url_count": 0
      }
    ],
    "Mentions:screen_name": [
      {
        "indices": [121, 130],
        "annotationID": 3
      }
    ],
    "Mentions:description": [
      {
        "indices": [131, 174],
        "annotationID": 4,
        "org_count": 0,
        "first_singular_count": 0,
        "org_lookup_count": 0,
        "occ_lookup_count": 0,
        "disclaimer_count": 0,
        "occupation_count": 1,
        "preposition_place_count": 0,
        "loc_count": 0,
        "loc_lookup_count": 0,
        "url_count": 0,
        "per_count": 0,
        "official_count": 0,
        "token_count": 5,
        "per_lookup_count": 0,
        "first_plural_count": 0
      }
    ],
    "Mentions:location": [
      {
        "indices": [175, 204],
        "annotationID": 5
      }
    ],
    "Mentions:UserID": [
      {
        "indices": [119, 204],
        "annotationID": 6,
        "max-bncorg-score": 0.8086047,
        "max-org-score": 0.8086047,
        "mean-bncorg-score": 0.09787908,
        "disclaimer_count": 0,
        "max-loc-score": 0.0,
        "sum-bncorg-score": 1.5660653,
        "user": "B_brewer2",
        "followees": 577,
        "description": "Peoples champion. #CMU Instagram @b_brewer2",
        "followers": 724,
        "location": "Mount Pleasant / Dirty Mitten",
        "mean-per-score": 0.4874386,
        "more-person": 1,
        "notFound": true,
        "created_at": 1315691952000,
        "profile_image_url": "http://pbs.twimg.com/profile_images/669622972974571520/JZ4-ZJtc_normal.jpg",
        "posts_per_day": 3.2210307946401304,
        "occupation_count": 1,
        "official_count": 0,
        "mean-org-score": 0.12279078,
        "sum-org-score": 2.0874434,
        "tweet_count": 5020,
        "correct": "person",
        "url": null,
        "sum-per-score": 8.286456,
        "lang": "en",
        "mean-loc-score": 0.0,
        "kind": "UserID",
        "preposition_place_count": 0,
        "string": "@B_brewer2",
        "sum-loc-score": 0.0,
        "verified": false,
        "name": "B",
        "max-per-score": 0.23887041
      }
    ],
    "Mentions:Lookup": [
      {
        "indices": [78, 79],
        "annotationID": 7707,
        "majorType": "First_Singular"
      }, {
        "indices": [109, 111],
        "annotationID": 7708,
        "majorType": "First_Plural"
      }, {
        "indices": [139, 147],
        "annotationID": 7709,
        "majorType": "occupation"
      }, {
        "indices": [175, 189],
        "annotationID": 7710,
        "majorType": "location",
        "minorType": "city"
      }
    ],
    "Mentions:Token": [
      {
        "indices": [139, 147],
        "annotationID": 7711,
        "string": "champion",
        "length": "8",
        "orth": "lowercase",
        "kind": "word",
        "category": "NN",
        "org-sim": -0.0,
        "per-sim": 0.7443621442870574,
        "loc-sim": 0.23887041511105644
      }, {
        "indices": [147, 148],
        "annotationID": 7712,
        "string": ".",
        "length": "1",
        "kind": "punctuation",
        "category": ".",
        "org-sim": 0,
        "per-sim": 0,
        "loc-sim": 0
      }, {
        "indices": [154, 163],
        "annotationID": 7713,
        "string": "Instagram",
        "length": "9",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NNP",
        "org-sim": 0,
        "per-sim": 0,
        "loc-sim": 0
      }, {
        "indices": [175, 180],
        "annotationID": 7714,
        "string": "Mount",
        "length": "5",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NNP",
        "org-sim": 0.22064662513322142,
        "per-sim": 0.8544417447098271,
        "loc-sim": 0.35473442086545404
      }, {
        "indices": [181, 189],
        "annotationID": 7715,
        "string": "Pleasant",
        "length": "8",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NNP",
        "org-sim": 0.0,
        "per-sim": 0.0,
        "loc-sim": 0.0
      }, {
        "indices": [190, 191],
        "annotationID": 7716,
        "string": "/",
        "length": "1",
        "kind": "punctuation",
        "category": "CC",
        "org-sim": 0,
        "per-sim": 0,
        "loc-sim": 0
      }, {
        "indices": [192, 197],
        "annotationID": 7717,
        "string": "Dirty",
        "length": "5",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NNP",
        "org-sim": 0.0,
        "per-sim": 0.0,
        "loc-sim": 0.0
      }, {
        "indices": [198, 204],
        "annotationID": 7719,
        "string": "Mitten",
        "length": "6",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NNP",
        "org-sim": -0.0,
        "per-sim": 0.8602843454589831,
        "loc-sim": 0.14924995185671222
      }, {
        "indices": [123, 130],
        "annotationID": 7720,
        "origString": "brewer2",
        "rule": "Recombine",
        "kind": "word",
        "length": 7,
        "string": "brewers",
        "orth": "mixed",
        "replaced": 2,
        "category": "NNS",
        "org-sim": -0.0,
        "per-sim": 0.4837099947797898,
        "loc-sim": 0.1747547657141122
      }, {
        "indices": [164, 174],
        "annotationID": 7721,
        "rule": "UserID",
        "category": "USR",
        "kind": "word",
        "length": 10,
        "string": "b_brewer2",
        "org-sim": 0.2684069630244764,
        "per-sim": 1.0969684202555057,
        "loc-sim": 0.20712321756479615
      }, {
        "indices": [149, 150],
        "annotationID": 7722,
        "string": "#",
        "length": "1",
        "kind": "punctuation",
        "category": "HT",
        "org-sim": 0,
        "per-sim": 0,
        "loc-sim": 0
      }, {
        "indices": [150, 152],
        "annotationID": 7723,
        "string": "CM",
        "length": "2",
        "kind": "word",
        "orth": "allCaps",
        "origString": "CM",
        "category": "NNP",
        "org-sim": 0.21253024110815663,
        "per-sim": 0.2372382603579653,
        "loc-sim": 0.1139366677744672
      }, {
        "indices": [152, 153],
        "annotationID": 7724,
        "string": "U",
        "length": "1",
        "kind": "word",
        "orth": "allCaps",
        "origString": "U",
        "category": "NNP",
        "org-sim": 0.30884802775026887,
        "per-sim": 0.363927858878418,
        "loc-sim": 0.1244179026847359
      }, {
        "indices": [115, 120],
        "annotationID": 7725,
        "string": "callB",
        "length": "5",
        "orth": "mixedCaps",
        "kind": "word",
        "origString": "callB",
        "category": "NN",
        "org-sim": 0,
        "per-sim": 0,
        "loc-sim": 0
      }, {
        "indices": [121, 122],
        "annotationID": 7726,
        "string": "B",
        "length": "1",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NN",
        "org-sim": 0.2684069630244764,
        "per-sim": 1.0969684202555057,
        "loc-sim": 0.20712321756479615
      }, {
        "indices": [122, 123],
        "annotationID": 7727,
        "string": "_",
        "length": "1",
        "kind": "punctuation",
        "category": "UH",
        "org-sim": 0,
        "per-sim": 0,
        "loc-sim": 0
      }, {
        "indices": [131, 138],
        "annotationID": 7728,
        "string": "Peoples",
        "length": "7",
        "orth": "upperInitial",
        "kind": "word",
        "category": "NNS",
        "org-sim": 0.8086046876737905,
        "per-sim": 0.9171646205032922,
        "loc-sim": 0.06117905021185258
      }
    ],
    "Mentions:Location": [
      {
        "indices": [175, 189],
        "annotationID": 7718,
        "locType": "city",
        "rule": "Location1",
        "ruleFinal": "LocFinal"
      }
    ],
    "Mentions:OOV_word": [
      {
        "indices": [154, 163],
        "annotationID": 7729,
        "string": "Instagram"
      }, {
        "indices": [150, 152],
        "annotationID": 7730,
        "string": "CM"
      }
    ],
    "Mentions:OOV_span": [
      {
        "indices": [131, 174],
        "annotationID": 7731,
        "ratio": 0.4,
        "total": 5,
        "out_of_vocabulary": 2
      }
    ],
    "Mentions:screen_name_edit": [
      {
        "indices": [119, 130],
        "annotationID": 7733,
        "distance": 0
      }
    ],
    "Key:Tweet": [
      {
        "indices": [0, 207],
        "annotationID": 0,
        "id_str": 623643245826981888,
        "user:name": "Mason",
        "truncated": false,
        "source": "<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>",
        "user:location": "✋",
        "user:screen_name": "_TimMason"
      }
    ],
    "Key:UserID": [
      {
        "indices": [1, 10],
        "annotationID": 1,
        "location": "Mount Pleasant / Dirty Mitten",
        "description": "Peoples champion. #CMU Instagram @b_brewer2",
        "verified": false,
        "name": "B",
        "string": "@B_brewer2",
        "created_at": 1315691952000,
        "tweet_count": 4905,
        "user": "B_brewer2",
        "lang": "en",
        "kind": "UserID"
      }
    ]
  }
};

createTree = require("functional-red-black-tree");

entities = doc.entities;

AnnotationDisplay = (function() {

  /*
    Encapsulates the generation of the required DOM objects to show overlapping annotations
   */
  function AnnotationDisplay(text1, annotationSets, target) {
    var i, j, ref, ref1, results, results1;
    this.text = text1;
    this.annotationSets = annotationSets;
    this.target = target;
    this.colourField = (function() {
      results = [];
      for (var i = 0, ref = this.text.length; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map(function() {
      return [255, 255, 255, 1];
    });
    this.annotationsAt = (function() {
      results1 = [];
      for (var j = 0, ref1 = this.text.length; 0 <= ref1 ? j <= ref1 : j >= ref1; 0 <= ref1 ? j++ : j--){ results1.push(j); }
      return results1;
    }).apply(this).map(function() {
      return {};
    });
    this.typeColours = {};
    this.updateColourField();
    this.spans = this.getSpansInRange();
    this.spans = this.renderSpans(this.spans, this.text);
    this.update();
  }

  AnnotationDisplay.prototype.getTypeColour = function(type) {

    /* 
      Generates a colour for the given type, or retrieves it if there already is one.
     */
    var colour;
    if (indexOf.call(this.typeColours, type) >= 0) {
      return type;
    } else {
      colour = [(Math.random() * 75) + 180, (Math.random() * 75) + 180, (Math.random() * 75) + 180, 0.5];
      this.typeColours[type] = colour;
      return colour;
    }
  };

  AnnotationDisplay.prototype.combineAlpha = function(a, b) {

    /* Combines two colours, appying alpha channel */
    var alpha, c, i, len, out, ref;
    out = [0, 0, 0, 0];
    alpha = a[3] + b[3] * (1 - a[3]);
    out[3] = alpha;
    ref = [0, 1, 2];
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      out[c] = Math.floor((a[c] * a[3] + b[c] * b[3] * (1 - a[3])) / alpha);
    }
    return out;
  };

  AnnotationDisplay.prototype.updateColourField = function(start, end) {
    var annotation, annotations, i, index, j, offset, ref, ref1, ref2, results, results1, results2, type, typeColour;
    if (start == null) {
      start = null;
    }
    if (end == null) {
      end = null;
    }
    this.colourField = (function() {
      results = [];
      for (var i = 0, ref = this.text.length; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map(function() {
      return [255, 255, 255, 1];
    });
    this.annotationsAt = (function() {
      results1 = [];
      for (var j = 0, ref1 = this.text.length; 0 <= ref1 ? j <= ref1 : j >= ref1; 0 <= ref1 ? j++ : j--){ results1.push(j); }
      return results1;
    }).apply(this).map(function() {
      return {};
    });

    /* Calculates the colours at each offset in the document */
    ref2 = this.annotationSets;
    results2 = [];
    for (type in ref2) {
      annotations = ref2[type];
      typeColour = this.getTypeColour(type);
      results2.push((function() {
        var results3;
        results3 = [];
        for (index in annotations) {
          annotation = annotations[index];
          annotation.type = type;
          results3.push((function() {
            var k, ref3, ref4, results4;
            results4 = [];
            for (offset = k = ref3 = annotation.indices[0], ref4 = annotation.indices[1]; ref3 <= ref4 ? k <= ref4 : k >= ref4; offset = ref3 <= ref4 ? ++k : --k) {
              this.colourField[offset] = this.combineAlpha(typeColour, this.colourField[offset]);
              results4.push(this.annotationsAt[offset][annotation.annotationID] = annotation);
            }
            return results4;
          }).call(this));
        }
        return results3;
      }).call(this));
    }
    return results2;
  };

  AnnotationDisplay.prototype.getSpansInRange = function(start, end) {
    var colour, i, lastColour, lastOffset, offset, ref, ref1, spans;
    if (start == null) {
      start = null;
    }
    if (end == null) {
      end = null;
    }

    /* Returns the ranges for each colour area */
    lastColour = null;
    lastOffset = -1;
    start = start === null ? 0 : start;
    end = end === null ? this.colourField.length - 1 : end;
    spans = [];
    for (offset = i = ref = start, ref1 = end; ref <= ref1 ? i <= ref1 : i >= ref1; offset = ref <= ref1 ? ++i : --i) {
      colour = this.colourField[offset];
      if (!Object.equal(lastColour, colour)) {
        spans.push({
          start: lastOffset,
          end: offset - 1,
          colour: lastColour,
          annotations: this.annotationsAt[offset - 1]
        });
        lastColour = colour;
        lastOffset = offset;
      }
    }
    spans.push({
      start: lastOffset,
      end: end,
      colour: lastColour,
      annotations: this.annotationsAt[end - 1]
    });
    return spans;
  };

  AnnotationDisplay.prototype.renderSpans = function(spans) {

    /* Converts the specified spans to nodes in the document
    
    Returns a copy of the spans with the nodes attached as a field
     */
    var colour, i, len, result, span, spanNode, text, textNode;
    result = [];
    for (i = 0, len = spans.length; i < len; i++) {
      span = spans[i];
      text = this.text.slice(span.start, +span.end + 1 || 9e9);
      textNode = document.createTextNode(text);
      spanNode = document.createElement("span");
      colour = span.colour;
      if (colour !== null) {
        spanNode.style["background-color"] = "rgba(" + colour[0] + ", " + colour[1] + ", " + colour[2] + ", " + colour[3] + ")";
      }
      span = $.extend({}, span, {
        node: spanNode
      });
      this.attachEvents(span);
      result.append(span);
    }
    return result;
  };

  AnnotationDisplay.prototype.attachEvents = function(span) {
    $(span.node).on("mouseover", null, span, (function(_this) {
      return function(event) {
        return _this.showSpan(event.data);
      };
    })(this));
    return $(span.node).on("click", null, span, (function(_this) {
      return function(event) {
        return _this.deleteSpan(event.data);
      };
    })(this));
  };

  AnnotationDisplay.prototype.showSpan = function(span) {
    var annotation, annotationId, ref, text;
    text = "";
    ref = span.annotations;
    for (annotationId in ref) {
      annotation = ref[annotationId];
      text += annotation.type + "<br />";
    }
    return $("#annotationInfo").html(text);
  };

  AnnotationDisplay.prototype.deleteSpan = function(span) {
    var annotation, annotationId, ref, results;
    ref = span.annotations;
    results = [];
    for (annotationId in ref) {
      annotation = ref[annotationId];
      this.removeAnnotation(annotation);
      break;
    }
    return results;
  };

  AnnotationDisplay.prototype.update = function() {
    var result, span;
    result = document.createElement("div");
    $(result).append((function() {
      var i, len, ref, results;
      ref = this.spans;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        span = ref[i];
        results.push(span.node);
      }
      return results;
    }).call(this));
    return this.target.replaceWith(result);
  };

  AnnotationDisplay.prototype.removeAnnotation = function(annotation) {
    var annotationId, colour, first, i, len, old, ref, ref1, result, span, spanNode, text, textNode;
    this.annotationSets[annotation.type] = this.annotationSets[annotation.type].filter(function(ann) {
      return ann !== annotation;
    });
    this.updateColourField(annotation.indices[0], annotation.indices[1]);
    old = annotation.documentNodes;
    console.log(old);
    annotation.documentNodes = [];
    result = [];
    console.log(this.getColourRanges(annotation.indices[0], annotation.indices[1]));
    ref = this.getColourRanges(annotation.indices[0], annotation.indices[1]);
    for (i = 0, len = ref.length; i < len; i++) {
      span = ref[i];
      text = this.text.slice(span.start, +span.end + 1 || 9e9);
      textNode = document.createTextNode(text);
      spanNode = document.createElement("span");
      colour = span.colour;
      if (colour !== null) {
        spanNode.style["background-color"] = "rgba(" + colour[0] + ", " + colour[1] + ", " + colour[2] + ", " + colour[3] + ")";
      }
      spanNode.appendChild(textNode);
      result.push(spanNode);
      $(spanNode).on("mouseover", null, span, (function(_this) {
        return function(event) {
          var annotationId, ref1;
          text = "";
          ref1 = event.data.annotations;
          for (annotationId in ref1) {
            annotation = ref1[annotationId];
            text += annotation.type + "<br />";
          }
          return $("#annotationInfo").html(text);
        };
      })(this));
      $(spanNode).on("click", null, span, (function(_this) {
        return function(event) {
          var annotationId, ref1, results;
          ref1 = event.data.annotations;
          results = [];
          for (annotationId in ref1) {
            annotation = ref1[annotationId];
            _this.removeAnnotation(annotation);
            break;
          }
          return results;
        };
      })(this));
      ref1 = span.annotations;
      for (annotationId in ref1) {
        annotation = ref1[annotationId];
        annotation.documentNodes = annotation.documentNodes.filter(function(node) {
          return indexOf.call(old, node) < 0;
        });
        if ("documentNodes" in annotation) {
          annotation.documentNodes.push(spanNode);
        } else {
          annotation.documentNodes = [spanNode];
        }
      }
    }
    first = $(old).first();
    console.log(result);
    first.before(result);
    return $(old).remove();
  };

  return AnnotationDisplay;

})();

$().ready(function() {
  var display;
  display = new AnnotationDisplay(doc.text, doc.entities);
  return display.update($("#docView"));
});



},{"functional-red-black-tree":2}],2:[function(require,module,exports){
"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}

function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})

Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})

//Insert a new item into the tree
proto.insert = function(key, value) {
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}


//Visit all nodes inorder
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}


proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}

//First item in list
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Last item in list
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Find the ith item in the tree
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}

proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

//Finds the item with key if it exists
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}

//Removes item with key from tree
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}

//Returns the item at `key`
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})

//Makes a copy of an iterator
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) {
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Returns key
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})

//Returns value
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})

//Advances iterator to next element in list
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Update value
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Moves iterator backward one element
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Default comparison function
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImFubm90YXRpb25EaXNwbGF5LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uYWwtcmVkLWJsYWNrLXRyZWUvcmJ0cmVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTEuMVxudmFyIEFubm90YXRpb25EaXNwbGF5LCBjcmVhdGVUcmVlLCBkb2MsIGVudGl0aWVzLFxuICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbmRvYyA9IHtcbiAgXCJ0ZXh0XCI6IFwiQEJfYnJld2VyMiB3YXMgZ29ubmEgYmUgZWFybHkgbGlrZSA5aXNoIGN1eiBoZSBkaWRuJ3Qgd2FubmEgc3RheSBvdXQgbGF0ZSBhbmQgSSBoYXZlIGEgZG9jIGFwdCB0b21vcnJvdy4gQnV0IHdlJ2xsIGNhbGxCIEJfYnJld2VyMiBQZW9wbGVzIGNoYW1waW9uLiAjQ01VIEluc3RhZ3JhbSBAYl9icmV3ZXIyIE1vdW50IFBsZWFzYW50IC8gRGlydHkgTWl0dGVuIFxcblxcblwiLFxuICBcImVudGl0aWVzXCI6IHtcbiAgICBcIk1lbnRpb25zOm5hbWVcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGljZXNcIjogWzExOSwgMTIwXSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogMixcbiAgICAgICAgXCJvcmdfbG9va3VwX2NvdW50XCI6IDAsXG4gICAgICAgIFwiZGlzY2xhaW1lcl9jb3VudFwiOiAwLFxuICAgICAgICBcImZpcnN0X3BsdXJhbF9jb3VudFwiOiAwLFxuICAgICAgICBcImZpcnN0X3Npbmd1bGFyX2NvdW50XCI6IDAsXG4gICAgICAgIFwibG9jX2xvb2t1cF9jb3VudFwiOiAwLFxuICAgICAgICBcIm9jY19sb29rdXBfY291bnRcIjogMCxcbiAgICAgICAgXCJvZmZpY2lhbF9jb3VudFwiOiAwLFxuICAgICAgICBcInBlcl9sb29rdXBfY291bnRcIjogMCxcbiAgICAgICAgXCJwcmVwb3NpdGlvbl9wbGFjZV9jb3VudFwiOiAwLFxuICAgICAgICBcInRva2VuX2NvdW50XCI6IDEsXG4gICAgICAgIFwidXJsX2NvdW50XCI6IDBcbiAgICAgIH1cbiAgICBdLFxuICAgIFwiTWVudGlvbnM6c2NyZWVuX25hbWVcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGljZXNcIjogWzEyMSwgMTMwXSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogM1xuICAgICAgfVxuICAgIF0sXG4gICAgXCJNZW50aW9uczpkZXNjcmlwdGlvblwiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTMxLCAxNzRdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA0LFxuICAgICAgICBcIm9yZ19jb3VudFwiOiAwLFxuICAgICAgICBcImZpcnN0X3Npbmd1bGFyX2NvdW50XCI6IDAsXG4gICAgICAgIFwib3JnX2xvb2t1cF9jb3VudFwiOiAwLFxuICAgICAgICBcIm9jY19sb29rdXBfY291bnRcIjogMCxcbiAgICAgICAgXCJkaXNjbGFpbWVyX2NvdW50XCI6IDAsXG4gICAgICAgIFwib2NjdXBhdGlvbl9jb3VudFwiOiAxLFxuICAgICAgICBcInByZXBvc2l0aW9uX3BsYWNlX2NvdW50XCI6IDAsXG4gICAgICAgIFwibG9jX2NvdW50XCI6IDAsXG4gICAgICAgIFwibG9jX2xvb2t1cF9jb3VudFwiOiAwLFxuICAgICAgICBcInVybF9jb3VudFwiOiAwLFxuICAgICAgICBcInBlcl9jb3VudFwiOiAwLFxuICAgICAgICBcIm9mZmljaWFsX2NvdW50XCI6IDAsXG4gICAgICAgIFwidG9rZW5fY291bnRcIjogNSxcbiAgICAgICAgXCJwZXJfbG9va3VwX2NvdW50XCI6IDAsXG4gICAgICAgIFwiZmlyc3RfcGx1cmFsX2NvdW50XCI6IDBcbiAgICAgIH1cbiAgICBdLFxuICAgIFwiTWVudGlvbnM6bG9jYXRpb25cIjogW1xuICAgICAge1xuICAgICAgICBcImluZGljZXNcIjogWzE3NSwgMjA0XSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNVxuICAgICAgfVxuICAgIF0sXG4gICAgXCJNZW50aW9uczpVc2VySURcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGljZXNcIjogWzExOSwgMjA0XSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNixcbiAgICAgICAgXCJtYXgtYm5jb3JnLXNjb3JlXCI6IDAuODA4NjA0NyxcbiAgICAgICAgXCJtYXgtb3JnLXNjb3JlXCI6IDAuODA4NjA0NyxcbiAgICAgICAgXCJtZWFuLWJuY29yZy1zY29yZVwiOiAwLjA5Nzg3OTA4LFxuICAgICAgICBcImRpc2NsYWltZXJfY291bnRcIjogMCxcbiAgICAgICAgXCJtYXgtbG9jLXNjb3JlXCI6IDAuMCxcbiAgICAgICAgXCJzdW0tYm5jb3JnLXNjb3JlXCI6IDEuNTY2MDY1MyxcbiAgICAgICAgXCJ1c2VyXCI6IFwiQl9icmV3ZXIyXCIsXG4gICAgICAgIFwiZm9sbG93ZWVzXCI6IDU3NyxcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlBlb3BsZXMgY2hhbXBpb24uICNDTVUgSW5zdGFncmFtIEBiX2JyZXdlcjJcIixcbiAgICAgICAgXCJmb2xsb3dlcnNcIjogNzI0LFxuICAgICAgICBcImxvY2F0aW9uXCI6IFwiTW91bnQgUGxlYXNhbnQgLyBEaXJ0eSBNaXR0ZW5cIixcbiAgICAgICAgXCJtZWFuLXBlci1zY29yZVwiOiAwLjQ4NzQzODYsXG4gICAgICAgIFwibW9yZS1wZXJzb25cIjogMSxcbiAgICAgICAgXCJub3RGb3VuZFwiOiB0cnVlLFxuICAgICAgICBcImNyZWF0ZWRfYXRcIjogMTMxNTY5MTk1MjAwMCxcbiAgICAgICAgXCJwcm9maWxlX2ltYWdlX3VybFwiOiBcImh0dHA6Ly9wYnMudHdpbWcuY29tL3Byb2ZpbGVfaW1hZ2VzLzY2OTYyMjk3Mjk3NDU3MTUyMC9KWjQtWkp0Y19ub3JtYWwuanBnXCIsXG4gICAgICAgIFwicG9zdHNfcGVyX2RheVwiOiAzLjIyMTAzMDc5NDY0MDEzMDQsXG4gICAgICAgIFwib2NjdXBhdGlvbl9jb3VudFwiOiAxLFxuICAgICAgICBcIm9mZmljaWFsX2NvdW50XCI6IDAsXG4gICAgICAgIFwibWVhbi1vcmctc2NvcmVcIjogMC4xMjI3OTA3OCxcbiAgICAgICAgXCJzdW0tb3JnLXNjb3JlXCI6IDIuMDg3NDQzNCxcbiAgICAgICAgXCJ0d2VldF9jb3VudFwiOiA1MDIwLFxuICAgICAgICBcImNvcnJlY3RcIjogXCJwZXJzb25cIixcbiAgICAgICAgXCJ1cmxcIjogbnVsbCxcbiAgICAgICAgXCJzdW0tcGVyLXNjb3JlXCI6IDguMjg2NDU2LFxuICAgICAgICBcImxhbmdcIjogXCJlblwiLFxuICAgICAgICBcIm1lYW4tbG9jLXNjb3JlXCI6IDAuMCxcbiAgICAgICAgXCJraW5kXCI6IFwiVXNlcklEXCIsXG4gICAgICAgIFwicHJlcG9zaXRpb25fcGxhY2VfY291bnRcIjogMCxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJAQl9icmV3ZXIyXCIsXG4gICAgICAgIFwic3VtLWxvYy1zY29yZVwiOiAwLjAsXG4gICAgICAgIFwidmVyaWZpZWRcIjogZmFsc2UsXG4gICAgICAgIFwibmFtZVwiOiBcIkJcIixcbiAgICAgICAgXCJtYXgtcGVyLXNjb3JlXCI6IDAuMjM4ODcwNDFcbiAgICAgIH1cbiAgICBdLFxuICAgIFwiTWVudGlvbnM6TG9va3VwXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFs3OCwgNzldLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzA3LFxuICAgICAgICBcIm1ham9yVHlwZVwiOiBcIkZpcnN0X1Npbmd1bGFyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxMDksIDExMV0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MDgsXG4gICAgICAgIFwibWFqb3JUeXBlXCI6IFwiRmlyc3RfUGx1cmFsXCJcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxMzksIDE0N10sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MDksXG4gICAgICAgIFwibWFqb3JUeXBlXCI6IFwib2NjdXBhdGlvblwiXG4gICAgICB9LCB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTc1LCAxODldLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzEwLFxuICAgICAgICBcIm1ham9yVHlwZVwiOiBcImxvY2F0aW9uXCIsXG4gICAgICAgIFwibWlub3JUeXBlXCI6IFwiY2l0eVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIk1lbnRpb25zOlRva2VuXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxMzksIDE0N10sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MTEsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiY2hhbXBpb25cIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCI4XCIsXG4gICAgICAgIFwib3J0aFwiOiBcImxvd2VyY2FzZVwiLFxuICAgICAgICBcImtpbmRcIjogXCJ3b3JkXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJOTlwiLFxuICAgICAgICBcIm9yZy1zaW1cIjogLTAuMCxcbiAgICAgICAgXCJwZXItc2ltXCI6IDAuNzQ0MzYyMTQ0Mjg3MDU3NCxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMjM4ODcwNDE1MTExMDU2NDRcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxNDcsIDE0OF0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MTIsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiLlwiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjFcIixcbiAgICAgICAgXCJraW5kXCI6IFwicHVuY3R1YXRpb25cIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIi5cIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAsXG4gICAgICAgIFwicGVyLXNpbVwiOiAwLFxuICAgICAgICBcImxvYy1zaW1cIjogMFxuICAgICAgfSwge1xuICAgICAgICBcImluZGljZXNcIjogWzE1NCwgMTYzXSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcxMyxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJJbnN0YWdyYW1cIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCI5XCIsXG4gICAgICAgIFwib3J0aFwiOiBcInVwcGVySW5pdGlhbFwiLFxuICAgICAgICBcImtpbmRcIjogXCJ3b3JkXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJOTlBcIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAsXG4gICAgICAgIFwicGVyLXNpbVwiOiAwLFxuICAgICAgICBcImxvYy1zaW1cIjogMFxuICAgICAgfSwge1xuICAgICAgICBcImluZGljZXNcIjogWzE3NSwgMTgwXSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcxNCxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJNb3VudFwiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjVcIixcbiAgICAgICAgXCJvcnRoXCI6IFwidXBwZXJJbml0aWFsXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIk5OUFwiLFxuICAgICAgICBcIm9yZy1zaW1cIjogMC4yMjA2NDY2MjUxMzMyMjE0MixcbiAgICAgICAgXCJwZXItc2ltXCI6IDAuODU0NDQxNzQ0NzA5ODI3MSxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMzU0NzM0NDIwODY1NDU0MDRcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxODEsIDE4OV0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MTUsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiUGxlYXNhbnRcIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCI4XCIsXG4gICAgICAgIFwib3J0aFwiOiBcInVwcGVySW5pdGlhbFwiLFxuICAgICAgICBcImtpbmRcIjogXCJ3b3JkXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJOTlBcIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAuMCxcbiAgICAgICAgXCJwZXItc2ltXCI6IDAuMCxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMFxuICAgICAgfSwge1xuICAgICAgICBcImluZGljZXNcIjogWzE5MCwgMTkxXSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcxNixcbiAgICAgICAgXCJzdHJpbmdcIjogXCIvXCIsXG4gICAgICAgIFwibGVuZ3RoXCI6IFwiMVwiLFxuICAgICAgICBcImtpbmRcIjogXCJwdW5jdHVhdGlvblwiLFxuICAgICAgICBcImNhdGVnb3J5XCI6IFwiQ0NcIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAsXG4gICAgICAgIFwicGVyLXNpbVwiOiAwLFxuICAgICAgICBcImxvYy1zaW1cIjogMFxuICAgICAgfSwge1xuICAgICAgICBcImluZGljZXNcIjogWzE5MiwgMTk3XSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcxNyxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJEaXJ0eVwiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjVcIixcbiAgICAgICAgXCJvcnRoXCI6IFwidXBwZXJJbml0aWFsXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIk5OUFwiLFxuICAgICAgICBcIm9yZy1zaW1cIjogMC4wLFxuICAgICAgICBcInBlci1zaW1cIjogMC4wLFxuICAgICAgICBcImxvYy1zaW1cIjogMC4wXG4gICAgICB9LCB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTk4LCAyMDRdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzE5LFxuICAgICAgICBcInN0cmluZ1wiOiBcIk1pdHRlblwiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjZcIixcbiAgICAgICAgXCJvcnRoXCI6IFwidXBwZXJJbml0aWFsXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIk5OUFwiLFxuICAgICAgICBcIm9yZy1zaW1cIjogLTAuMCxcbiAgICAgICAgXCJwZXItc2ltXCI6IDAuODYwMjg0MzQ1NDU4OTgzMSxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMTQ5MjQ5OTUxODU2NzEyMjJcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxMjMsIDEzMF0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MjAsXG4gICAgICAgIFwib3JpZ1N0cmluZ1wiOiBcImJyZXdlcjJcIixcbiAgICAgICAgXCJydWxlXCI6IFwiUmVjb21iaW5lXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJsZW5ndGhcIjogNyxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJicmV3ZXJzXCIsXG4gICAgICAgIFwib3J0aFwiOiBcIm1peGVkXCIsXG4gICAgICAgIFwicmVwbGFjZWRcIjogMixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIk5OU1wiLFxuICAgICAgICBcIm9yZy1zaW1cIjogLTAuMCxcbiAgICAgICAgXCJwZXItc2ltXCI6IDAuNDgzNzA5OTk0Nzc5Nzg5OCxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMTc0NzU0NzY1NzE0MTEyMlxuICAgICAgfSwge1xuICAgICAgICBcImluZGljZXNcIjogWzE2NCwgMTc0XSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcyMSxcbiAgICAgICAgXCJydWxlXCI6IFwiVXNlcklEXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJVU1JcIixcbiAgICAgICAgXCJraW5kXCI6IFwid29yZFwiLFxuICAgICAgICBcImxlbmd0aFwiOiAxMCxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJiX2JyZXdlcjJcIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAuMjY4NDA2OTYzMDI0NDc2NCxcbiAgICAgICAgXCJwZXItc2ltXCI6IDEuMDk2OTY4NDIwMjU1NTA1NyxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMjA3MTIzMjE3NTY0Nzk2MTVcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxNDksIDE1MF0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MjIsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiI1wiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjFcIixcbiAgICAgICAgXCJraW5kXCI6IFwicHVuY3R1YXRpb25cIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIkhUXCIsXG4gICAgICAgIFwib3JnLXNpbVwiOiAwLFxuICAgICAgICBcInBlci1zaW1cIjogMCxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxNTAsIDE1Ml0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MjMsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiQ01cIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCIyXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJvcnRoXCI6IFwiYWxsQ2Fwc1wiLFxuICAgICAgICBcIm9yaWdTdHJpbmdcIjogXCJDTVwiLFxuICAgICAgICBcImNhdGVnb3J5XCI6IFwiTk5QXCIsXG4gICAgICAgIFwib3JnLXNpbVwiOiAwLjIxMjUzMDI0MTEwODE1NjYzLFxuICAgICAgICBcInBlci1zaW1cIjogMC4yMzcyMzgyNjAzNTc5NjUzLFxuICAgICAgICBcImxvYy1zaW1cIjogMC4xMTM5MzY2Njc3NzQ0NjcyXG4gICAgICB9LCB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTUyLCAxNTNdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzI0LFxuICAgICAgICBcInN0cmluZ1wiOiBcIlVcIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCIxXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJvcnRoXCI6IFwiYWxsQ2Fwc1wiLFxuICAgICAgICBcIm9yaWdTdHJpbmdcIjogXCJVXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJOTlBcIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAuMzA4ODQ4MDI3NzUwMjY4ODcsXG4gICAgICAgIFwicGVyLXNpbVwiOiAwLjM2MzkyNzg1ODg3ODQxOCxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMTI0NDE3OTAyNjg0NzM1OVxuICAgICAgfSwge1xuICAgICAgICBcImluZGljZXNcIjogWzExNSwgMTIwXSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcyNSxcbiAgICAgICAgXCJzdHJpbmdcIjogXCJjYWxsQlwiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjVcIixcbiAgICAgICAgXCJvcnRoXCI6IFwibWl4ZWRDYXBzXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJvcmlnU3RyaW5nXCI6IFwiY2FsbEJcIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIk5OXCIsXG4gICAgICAgIFwib3JnLXNpbVwiOiAwLFxuICAgICAgICBcInBlci1zaW1cIjogMCxcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxMjEsIDEyMl0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MjYsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiQlwiLFxuICAgICAgICBcImxlbmd0aFwiOiBcIjFcIixcbiAgICAgICAgXCJvcnRoXCI6IFwidXBwZXJJbml0aWFsXCIsXG4gICAgICAgIFwia2luZFwiOiBcIndvcmRcIixcbiAgICAgICAgXCJjYXRlZ29yeVwiOiBcIk5OXCIsXG4gICAgICAgIFwib3JnLXNpbVwiOiAwLjI2ODQwNjk2MzAyNDQ3NjQsXG4gICAgICAgIFwicGVyLXNpbVwiOiAxLjA5Njk2ODQyMDI1NTUwNTcsXG4gICAgICAgIFwibG9jLXNpbVwiOiAwLjIwNzEyMzIxNzU2NDc5NjE1XG4gICAgICB9LCB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTIyLCAxMjNdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzI3LFxuICAgICAgICBcInN0cmluZ1wiOiBcIl9cIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCIxXCIsXG4gICAgICAgIFwia2luZFwiOiBcInB1bmN0dWF0aW9uXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJVSFwiLFxuICAgICAgICBcIm9yZy1zaW1cIjogMCxcbiAgICAgICAgXCJwZXItc2ltXCI6IDAsXG4gICAgICAgIFwibG9jLXNpbVwiOiAwXG4gICAgICB9LCB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTMxLCAxMzhdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzI4LFxuICAgICAgICBcInN0cmluZ1wiOiBcIlBlb3BsZXNcIixcbiAgICAgICAgXCJsZW5ndGhcIjogXCI3XCIsXG4gICAgICAgIFwib3J0aFwiOiBcInVwcGVySW5pdGlhbFwiLFxuICAgICAgICBcImtpbmRcIjogXCJ3b3JkXCIsXG4gICAgICAgIFwiY2F0ZWdvcnlcIjogXCJOTlNcIixcbiAgICAgICAgXCJvcmctc2ltXCI6IDAuODA4NjA0Njg3NjczNzkwNSxcbiAgICAgICAgXCJwZXItc2ltXCI6IDAuOTE3MTY0NjIwNTAzMjkyMixcbiAgICAgICAgXCJsb2Mtc2ltXCI6IDAuMDYxMTc5MDUwMjExODUyNThcbiAgICAgIH1cbiAgICBdLFxuICAgIFwiTWVudGlvbnM6TG9jYXRpb25cIjogW1xuICAgICAge1xuICAgICAgICBcImluZGljZXNcIjogWzE3NSwgMTg5XSxcbiAgICAgICAgXCJhbm5vdGF0aW9uSURcIjogNzcxOCxcbiAgICAgICAgXCJsb2NUeXBlXCI6IFwiY2l0eVwiLFxuICAgICAgICBcInJ1bGVcIjogXCJMb2NhdGlvbjFcIixcbiAgICAgICAgXCJydWxlRmluYWxcIjogXCJMb2NGaW5hbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIk1lbnRpb25zOk9PVl93b3JkXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxNTQsIDE2M10sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MjksXG4gICAgICAgIFwic3RyaW5nXCI6IFwiSW5zdGFncmFtXCJcbiAgICAgIH0sIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxNTAsIDE1Ml0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDc3MzAsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiQ01cIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJNZW50aW9uczpPT1Zfc3BhblwiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTMxLCAxNzRdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzMxLFxuICAgICAgICBcInJhdGlvXCI6IDAuNCxcbiAgICAgICAgXCJ0b3RhbFwiOiA1LFxuICAgICAgICBcIm91dF9vZl92b2NhYnVsYXJ5XCI6IDJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwiTWVudGlvbnM6c2NyZWVuX25hbWVfZWRpdFwiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kaWNlc1wiOiBbMTE5LCAxMzBdLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiA3NzMzLFxuICAgICAgICBcImRpc3RhbmNlXCI6IDBcbiAgICAgIH1cbiAgICBdLFxuICAgIFwiS2V5OlR3ZWV0XCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFswLCAyMDddLFxuICAgICAgICBcImFubm90YXRpb25JRFwiOiAwLFxuICAgICAgICBcImlkX3N0clwiOiA2MjM2NDMyNDU4MjY5ODE4ODgsXG4gICAgICAgIFwidXNlcjpuYW1lXCI6IFwiTWFzb25cIixcbiAgICAgICAgXCJ0cnVuY2F0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwic291cmNlXCI6IFwiPGEgaHJlZj1cXFwiaHR0cDovL3R3aXR0ZXIuY29tL2Rvd25sb2FkL2FuZHJvaWRcXFwiIHJlbD1cXFwibm9mb2xsb3dcXFwiPlR3aXR0ZXIgZm9yIEFuZHJvaWQ8L2E+XCIsXG4gICAgICAgIFwidXNlcjpsb2NhdGlvblwiOiBcIuKci1wiLFxuICAgICAgICBcInVzZXI6c2NyZWVuX25hbWVcIjogXCJfVGltTWFzb25cIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJLZXk6VXNlcklEXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJpbmRpY2VzXCI6IFsxLCAxMF0sXG4gICAgICAgIFwiYW5ub3RhdGlvbklEXCI6IDEsXG4gICAgICAgIFwibG9jYXRpb25cIjogXCJNb3VudCBQbGVhc2FudCAvIERpcnR5IE1pdHRlblwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUGVvcGxlcyBjaGFtcGlvbi4gI0NNVSBJbnN0YWdyYW0gQGJfYnJld2VyMlwiLFxuICAgICAgICBcInZlcmlmaWVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJCXCIsXG4gICAgICAgIFwic3RyaW5nXCI6IFwiQEJfYnJld2VyMlwiLFxuICAgICAgICBcImNyZWF0ZWRfYXRcIjogMTMxNTY5MTk1MjAwMCxcbiAgICAgICAgXCJ0d2VldF9jb3VudFwiOiA0OTA1LFxuICAgICAgICBcInVzZXJcIjogXCJCX2JyZXdlcjJcIixcbiAgICAgICAgXCJsYW5nXCI6IFwiZW5cIixcbiAgICAgICAgXCJraW5kXCI6IFwiVXNlcklEXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbn07XG5cbmNyZWF0ZVRyZWUgPSByZXF1aXJlKFwiZnVuY3Rpb25hbC1yZWQtYmxhY2stdHJlZVwiKTtcblxuZW50aXRpZXMgPSBkb2MuZW50aXRpZXM7XG5cbkFubm90YXRpb25EaXNwbGF5ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qXG4gICAgRW5jYXBzdWxhdGVzIHRoZSBnZW5lcmF0aW9uIG9mIHRoZSByZXF1aXJlZCBET00gb2JqZWN0cyB0byBzaG93IG92ZXJsYXBwaW5nIGFubm90YXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBBbm5vdGF0aW9uRGlzcGxheSh0ZXh0MSwgYW5ub3RhdGlvblNldHMsIHRhcmdldCkge1xuICAgIHZhciBpLCBqLCByZWYsIHJlZjEsIHJlc3VsdHMsIHJlc3VsdHMxO1xuICAgIHRoaXMudGV4dCA9IHRleHQxO1xuICAgIHRoaXMuYW5ub3RhdGlvblNldHMgPSBhbm5vdGF0aW9uU2V0cztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmNvbG91ckZpZWxkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHJlZiA9IHRoaXMudGV4dC5sZW5ndGg7IDAgPD0gcmVmID8gaSA8PSByZWYgOiBpID49IHJlZjsgMCA8PSByZWYgPyBpKysgOiBpLS0peyByZXN1bHRzLnB1c2goaSk7IH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pLmFwcGx5KHRoaXMpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbMjU1LCAyNTUsIDI1NSwgMV07XG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uc0F0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwLCByZWYxID0gdGhpcy50ZXh0Lmxlbmd0aDsgMCA8PSByZWYxID8gaiA8PSByZWYxIDogaiA+PSByZWYxOyAwIDw9IHJlZjEgPyBqKysgOiBqLS0peyByZXN1bHRzMS5wdXNoKGopOyB9XG4gICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0pO1xuICAgIHRoaXMudHlwZUNvbG91cnMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZUNvbG91ckZpZWxkKCk7XG4gICAgdGhpcy5zcGFucyA9IHRoaXMuZ2V0U3BhbnNJblJhbmdlKCk7XG4gICAgdGhpcy5zcGFucyA9IHRoaXMucmVuZGVyU3BhbnModGhpcy5zcGFucywgdGhpcy50ZXh0KTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgQW5ub3RhdGlvbkRpc3BsYXkucHJvdG90eXBlLmdldFR5cGVDb2xvdXIgPSBmdW5jdGlvbih0eXBlKSB7XG5cbiAgICAvKiBcbiAgICAgIEdlbmVyYXRlcyBhIGNvbG91ciBmb3IgdGhlIGdpdmVuIHR5cGUsIG9yIHJldHJpZXZlcyBpdCBpZiB0aGVyZSBhbHJlYWR5IGlzIG9uZS5cbiAgICAgKi9cbiAgICB2YXIgY29sb3VyO1xuICAgIGlmIChpbmRleE9mLmNhbGwodGhpcy50eXBlQ29sb3VycywgdHlwZSkgPj0gMCkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG91ciA9IFsoTWF0aC5yYW5kb20oKSAqIDc1KSArIDE4MCwgKE1hdGgucmFuZG9tKCkgKiA3NSkgKyAxODAsIChNYXRoLnJhbmRvbSgpICogNzUpICsgMTgwLCAwLjVdO1xuICAgICAgdGhpcy50eXBlQ29sb3Vyc1t0eXBlXSA9IGNvbG91cjtcbiAgICAgIHJldHVybiBjb2xvdXI7XG4gICAgfVxuICB9O1xuXG4gIEFubm90YXRpb25EaXNwbGF5LnByb3RvdHlwZS5jb21iaW5lQWxwaGEgPSBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAvKiBDb21iaW5lcyB0d28gY29sb3VycywgYXBweWluZyBhbHBoYSBjaGFubmVsICovXG4gICAgdmFyIGFscGhhLCBjLCBpLCBsZW4sIG91dCwgcmVmO1xuICAgIG91dCA9IFswLCAwLCAwLCAwXTtcbiAgICBhbHBoYSA9IGFbM10gKyBiWzNdICogKDEgLSBhWzNdKTtcbiAgICBvdXRbM10gPSBhbHBoYTtcbiAgICByZWYgPSBbMCwgMSwgMl07XG4gICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjID0gcmVmW2ldO1xuICAgICAgb3V0W2NdID0gTWF0aC5mbG9vcigoYVtjXSAqIGFbM10gKyBiW2NdICogYlszXSAqICgxIC0gYVszXSkpIC8gYWxwaGEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIEFubm90YXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb2xvdXJGaWVsZCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIGksIGluZGV4LCBqLCBvZmZzZXQsIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0cywgcmVzdWx0czEsIHJlc3VsdHMyLCB0eXBlLCB0eXBlQ29sb3VyO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICBzdGFydCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jb2xvdXJGaWVsZCA9IChmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCByZWYgPSB0aGlzLnRleHQubGVuZ3RoOyAwIDw9IHJlZiA/IGkgPD0gcmVmIDogaSA+PSByZWY7IDAgPD0gcmVmID8gaSsrIDogaS0tKXsgcmVzdWx0cy5wdXNoKGkpOyB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KS5hcHBseSh0aGlzKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbnNBdCA9IChmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMCwgcmVmMSA9IHRoaXMudGV4dC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPD0gcmVmMSA6IGogPj0gcmVmMTsgMCA8PSByZWYxID8gaisrIDogai0tKXsgcmVzdWx0czEucHVzaChqKTsgfVxuICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9KTtcblxuICAgIC8qIENhbGN1bGF0ZXMgdGhlIGNvbG91cnMgYXQgZWFjaCBvZmZzZXQgaW4gdGhlIGRvY3VtZW50ICovXG4gICAgcmVmMiA9IHRoaXMuYW5ub3RhdGlvblNldHM7XG4gICAgcmVzdWx0czIgPSBbXTtcbiAgICBmb3IgKHR5cGUgaW4gcmVmMikge1xuICAgICAgYW5ub3RhdGlvbnMgPSByZWYyW3R5cGVdO1xuICAgICAgdHlwZUNvbG91ciA9IHRoaXMuZ2V0VHlwZUNvbG91cih0eXBlKTtcbiAgICAgIHJlc3VsdHMyLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0czM7XG4gICAgICAgIHJlc3VsdHMzID0gW107XG4gICAgICAgIGZvciAoaW5kZXggaW4gYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgIGFubm90YXRpb24udHlwZSA9IHR5cGU7XG4gICAgICAgICAgcmVzdWx0czMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaywgcmVmMywgcmVmNCwgcmVzdWx0czQ7XG4gICAgICAgICAgICByZXN1bHRzNCA9IFtdO1xuICAgICAgICAgICAgZm9yIChvZmZzZXQgPSBrID0gcmVmMyA9IGFubm90YXRpb24uaW5kaWNlc1swXSwgcmVmNCA9IGFubm90YXRpb24uaW5kaWNlc1sxXTsgcmVmMyA8PSByZWY0ID8gayA8PSByZWY0IDogayA+PSByZWY0OyBvZmZzZXQgPSByZWYzIDw9IHJlZjQgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvdXJGaWVsZFtvZmZzZXRdID0gdGhpcy5jb21iaW5lQWxwaGEodHlwZUNvbG91ciwgdGhpcy5jb2xvdXJGaWVsZFtvZmZzZXRdKTtcbiAgICAgICAgICAgICAgcmVzdWx0czQucHVzaCh0aGlzLmFubm90YXRpb25zQXRbb2Zmc2V0XVthbm5vdGF0aW9uLmFubm90YXRpb25JRF0gPSBhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzNDtcbiAgICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0czM7XG4gICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMyO1xuICB9O1xuXG4gIEFubm90YXRpb25EaXNwbGF5LnByb3RvdHlwZS5nZXRTcGFuc0luUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGNvbG91ciwgaSwgbGFzdENvbG91ciwgbGFzdE9mZnNldCwgb2Zmc2V0LCByZWYsIHJlZjEsIHNwYW5zO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICBzdGFydCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKiBSZXR1cm5zIHRoZSByYW5nZXMgZm9yIGVhY2ggY29sb3VyIGFyZWEgKi9cbiAgICBsYXN0Q29sb3VyID0gbnVsbDtcbiAgICBsYXN0T2Zmc2V0ID0gLTE7XG4gICAgc3RhcnQgPSBzdGFydCA9PT0gbnVsbCA/IDAgOiBzdGFydDtcbiAgICBlbmQgPSBlbmQgPT09IG51bGwgPyB0aGlzLmNvbG91ckZpZWxkLmxlbmd0aCAtIDEgOiBlbmQ7XG4gICAgc3BhbnMgPSBbXTtcbiAgICBmb3IgKG9mZnNldCA9IGkgPSByZWYgPSBzdGFydCwgcmVmMSA9IGVuZDsgcmVmIDw9IHJlZjEgPyBpIDw9IHJlZjEgOiBpID49IHJlZjE7IG9mZnNldCA9IHJlZiA8PSByZWYxID8gKytpIDogLS1pKSB7XG4gICAgICBjb2xvdXIgPSB0aGlzLmNvbG91ckZpZWxkW29mZnNldF07XG4gICAgICBpZiAoIU9iamVjdC5lcXVhbChsYXN0Q29sb3VyLCBjb2xvdXIpKSB7XG4gICAgICAgIHNwYW5zLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiBsYXN0T2Zmc2V0LFxuICAgICAgICAgIGVuZDogb2Zmc2V0IC0gMSxcbiAgICAgICAgICBjb2xvdXI6IGxhc3RDb2xvdXIsXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IHRoaXMuYW5ub3RhdGlvbnNBdFtvZmZzZXQgLSAxXVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdENvbG91ciA9IGNvbG91cjtcbiAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3BhbnMucHVzaCh7XG4gICAgICBzdGFydDogbGFzdE9mZnNldCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgY29sb3VyOiBsYXN0Q29sb3VyLFxuICAgICAgYW5ub3RhdGlvbnM6IHRoaXMuYW5ub3RhdGlvbnNBdFtlbmQgLSAxXVxuICAgIH0pO1xuICAgIHJldHVybiBzcGFucztcbiAgfTtcblxuICBBbm5vdGF0aW9uRGlzcGxheS5wcm90b3R5cGUucmVuZGVyU3BhbnMgPSBmdW5jdGlvbihzcGFucykge1xuXG4gICAgLyogQ29udmVydHMgdGhlIHNwZWNpZmllZCBzcGFucyB0byBub2RlcyBpbiB0aGUgZG9jdW1lbnRcbiAgICBcbiAgICBSZXR1cm5zIGEgY29weSBvZiB0aGUgc3BhbnMgd2l0aCB0aGUgbm9kZXMgYXR0YWNoZWQgYXMgYSBmaWVsZFxuICAgICAqL1xuICAgIHZhciBjb2xvdXIsIGksIGxlbiwgcmVzdWx0LCBzcGFuLCBzcGFuTm9kZSwgdGV4dCwgdGV4dE5vZGU7XG4gICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gc3BhbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgIHRleHQgPSB0aGlzLnRleHQuc2xpY2Uoc3Bhbi5zdGFydCwgK3NwYW4uZW5kICsgMSB8fCA5ZTkpO1xuICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgIHNwYW5Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBjb2xvdXIgPSBzcGFuLmNvbG91cjtcbiAgICAgIGlmIChjb2xvdXIgIT09IG51bGwpIHtcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCJyZ2JhKFwiICsgY29sb3VyWzBdICsgXCIsIFwiICsgY29sb3VyWzFdICsgXCIsIFwiICsgY29sb3VyWzJdICsgXCIsIFwiICsgY29sb3VyWzNdICsgXCIpXCI7XG4gICAgICB9XG4gICAgICBzcGFuID0gJC5leHRlbmQoe30sIHNwYW4sIHtcbiAgICAgICAgbm9kZTogc3Bhbk5vZGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hdHRhY2hFdmVudHMoc3Bhbik7XG4gICAgICByZXN1bHQuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIEFubm90YXRpb25EaXNwbGF5LnByb3RvdHlwZS5hdHRhY2hFdmVudHMgPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgJChzcGFuLm5vZGUpLm9uKFwibW91c2VvdmVyXCIsIG51bGwsIHNwYW4sIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zaG93U3BhbihldmVudC5kYXRhKTtcbiAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICAgIHJldHVybiAkKHNwYW4ubm9kZSkub24oXCJjbGlja1wiLCBudWxsLCBzcGFuLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZGVsZXRlU3BhbihldmVudC5kYXRhKTtcbiAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICB9O1xuXG4gIEFubm90YXRpb25EaXNwbGF5LnByb3RvdHlwZS5zaG93U3BhbiA9IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICB2YXIgYW5ub3RhdGlvbiwgYW5ub3RhdGlvbklkLCByZWYsIHRleHQ7XG4gICAgdGV4dCA9IFwiXCI7XG4gICAgcmVmID0gc3Bhbi5hbm5vdGF0aW9ucztcbiAgICBmb3IgKGFubm90YXRpb25JZCBpbiByZWYpIHtcbiAgICAgIGFubm90YXRpb24gPSByZWZbYW5ub3RhdGlvbklkXTtcbiAgICAgIHRleHQgKz0gYW5ub3RhdGlvbi50eXBlICsgXCI8YnIgLz5cIjtcbiAgICB9XG4gICAgcmV0dXJuICQoXCIjYW5ub3RhdGlvbkluZm9cIikuaHRtbCh0ZXh0KTtcbiAgfTtcblxuICBBbm5vdGF0aW9uRGlzcGxheS5wcm90b3R5cGUuZGVsZXRlU3BhbiA9IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICB2YXIgYW5ub3RhdGlvbiwgYW5ub3RhdGlvbklkLCByZWYsIHJlc3VsdHM7XG4gICAgcmVmID0gc3Bhbi5hbm5vdGF0aW9ucztcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChhbm5vdGF0aW9uSWQgaW4gcmVmKSB7XG4gICAgICBhbm5vdGF0aW9uID0gcmVmW2Fubm90YXRpb25JZF07XG4gICAgICB0aGlzLnJlbW92ZUFubm90YXRpb24oYW5ub3RhdGlvbik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgQW5ub3RhdGlvbkRpc3BsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQsIHNwYW47XG4gICAgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAkKHJlc3VsdCkuYXBwZW5kKChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlZiA9IHRoaXMuc3BhbnM7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3BhbiA9IHJlZltpXTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHNwYW4ubm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQucmVwbGFjZVdpdGgocmVzdWx0KTtcbiAgfTtcblxuICBBbm5vdGF0aW9uRGlzcGxheS5wcm90b3R5cGUucmVtb3ZlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uKGFubm90YXRpb24pIHtcbiAgICB2YXIgYW5ub3RhdGlvbklkLCBjb2xvdXIsIGZpcnN0LCBpLCBsZW4sIG9sZCwgcmVmLCByZWYxLCByZXN1bHQsIHNwYW4sIHNwYW5Ob2RlLCB0ZXh0LCB0ZXh0Tm9kZTtcbiAgICB0aGlzLmFubm90YXRpb25TZXRzW2Fubm90YXRpb24udHlwZV0gPSB0aGlzLmFubm90YXRpb25TZXRzW2Fubm90YXRpb24udHlwZV0uZmlsdGVyKGZ1bmN0aW9uKGFubikge1xuICAgICAgcmV0dXJuIGFubiAhPT0gYW5ub3RhdGlvbjtcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUNvbG91ckZpZWxkKGFubm90YXRpb24uaW5kaWNlc1swXSwgYW5ub3RhdGlvbi5pbmRpY2VzWzFdKTtcbiAgICBvbGQgPSBhbm5vdGF0aW9uLmRvY3VtZW50Tm9kZXM7XG4gICAgY29uc29sZS5sb2cob2xkKTtcbiAgICBhbm5vdGF0aW9uLmRvY3VtZW50Tm9kZXMgPSBbXTtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmdldENvbG91clJhbmdlcyhhbm5vdGF0aW9uLmluZGljZXNbMF0sIGFubm90YXRpb24uaW5kaWNlc1sxXSkpO1xuICAgIHJlZiA9IHRoaXMuZ2V0Q29sb3VyUmFuZ2VzKGFubm90YXRpb24uaW5kaWNlc1swXSwgYW5ub3RhdGlvbi5pbmRpY2VzWzFdKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNwYW4gPSByZWZbaV07XG4gICAgICB0ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKHNwYW4uc3RhcnQsICtzcGFuLmVuZCArIDEgfHwgOWU5KTtcbiAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICBzcGFuTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgY29sb3VyID0gc3Bhbi5jb2xvdXI7XG4gICAgICBpZiAoY29sb3VyICE9PSBudWxsKSB7XG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwicmdiYShcIiArIGNvbG91clswXSArIFwiLCBcIiArIGNvbG91clsxXSArIFwiLCBcIiArIGNvbG91clsyXSArIFwiLCBcIiArIGNvbG91clszXSArIFwiKVwiO1xuICAgICAgfVxuICAgICAgc3Bhbk5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgcmVzdWx0LnB1c2goc3Bhbk5vZGUpO1xuICAgICAgJChzcGFuTm9kZSkub24oXCJtb3VzZW92ZXJcIiwgbnVsbCwgc3BhbiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBhbm5vdGF0aW9uSWQsIHJlZjE7XG4gICAgICAgICAgdGV4dCA9IFwiXCI7XG4gICAgICAgICAgcmVmMSA9IGV2ZW50LmRhdGEuYW5ub3RhdGlvbnM7XG4gICAgICAgICAgZm9yIChhbm5vdGF0aW9uSWQgaW4gcmVmMSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IHJlZjFbYW5ub3RhdGlvbklkXTtcbiAgICAgICAgICAgIHRleHQgKz0gYW5ub3RhdGlvbi50eXBlICsgXCI8YnIgLz5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICQoXCIjYW5ub3RhdGlvbkluZm9cIikuaHRtbCh0ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgICQoc3Bhbk5vZGUpLm9uKFwiY2xpY2tcIiwgbnVsbCwgc3BhbiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBhbm5vdGF0aW9uSWQsIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgcmVmMSA9IGV2ZW50LmRhdGEuYW5ub3RhdGlvbnM7XG4gICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoYW5ub3RhdGlvbklkIGluIHJlZjEpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSByZWYxW2Fubm90YXRpb25JZF07XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVBbm5vdGF0aW9uKGFubm90YXRpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgcmVmMSA9IHNwYW4uYW5ub3RhdGlvbnM7XG4gICAgICBmb3IgKGFubm90YXRpb25JZCBpbiByZWYxKSB7XG4gICAgICAgIGFubm90YXRpb24gPSByZWYxW2Fubm90YXRpb25JZF07XG4gICAgICAgIGFubm90YXRpb24uZG9jdW1lbnROb2RlcyA9IGFubm90YXRpb24uZG9jdW1lbnROb2Rlcy5maWx0ZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwob2xkLCBub2RlKSA8IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoXCJkb2N1bWVudE5vZGVzXCIgaW4gYW5ub3RhdGlvbikge1xuICAgICAgICAgIGFubm90YXRpb24uZG9jdW1lbnROb2Rlcy5wdXNoKHNwYW5Ob2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbm5vdGF0aW9uLmRvY3VtZW50Tm9kZXMgPSBbc3Bhbk5vZGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZpcnN0ID0gJChvbGQpLmZpcnN0KCk7XG4gICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICBmaXJzdC5iZWZvcmUocmVzdWx0KTtcbiAgICByZXR1cm4gJChvbGQpLnJlbW92ZSgpO1xuICB9O1xuXG4gIHJldHVybiBBbm5vdGF0aW9uRGlzcGxheTtcblxufSkoKTtcblxuJCgpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICB2YXIgZGlzcGxheTtcbiAgZGlzcGxheSA9IG5ldyBBbm5vdGF0aW9uRGlzcGxheShkb2MudGV4dCwgZG9jLmVudGl0aWVzKTtcbiAgcmV0dXJuIGRpc3BsYXkudXBkYXRlKCQoXCIjZG9jVmlld1wiKSk7XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ub3RhdGlvbkRpc3BsYXkuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJCVHJlZVxuXG52YXIgUkVEICAgPSAwXG52YXIgQkxBQ0sgPSAxXG5cbmZ1bmN0aW9uIFJCTm9kZShjb2xvciwga2V5LCB2YWx1ZSwgbGVmdCwgcmlnaHQsIGNvdW50KSB7XG4gIHRoaXMuX2NvbG9yID0gY29sb3JcbiAgdGhpcy5rZXkgPSBrZXlcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMubGVmdCA9IGxlZnRcbiAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gIHRoaXMuX2NvdW50ID0gY291bnRcbn1cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBSQk5vZGUobm9kZS5fY29sb3IsIG5vZGUua2V5LCBub2RlLnZhbHVlLCBub2RlLmxlZnQsIG5vZGUucmlnaHQsIG5vZGUuX2NvdW50KVxufVxuXG5mdW5jdGlvbiByZXBhaW50KGNvbG9yLCBub2RlKSB7XG4gIHJldHVybiBuZXcgUkJOb2RlKGNvbG9yLCBub2RlLmtleSwgbm9kZS52YWx1ZSwgbm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBub2RlLl9jb3VudClcbn1cblxuZnVuY3Rpb24gcmVjb3VudChub2RlKSB7XG4gIG5vZGUuX2NvdW50ID0gMSArIChub2RlLmxlZnQgPyBub2RlLmxlZnQuX2NvdW50IDogMCkgKyAobm9kZS5yaWdodCA/IG5vZGUucmlnaHQuX2NvdW50IDogMClcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tUcmVlKGNvbXBhcmUsIHJvb3QpIHtcbiAgdGhpcy5fY29tcGFyZSA9IGNvbXBhcmVcbiAgdGhpcy5yb290ID0gcm9vdFxufVxuXG52YXIgcHJvdG8gPSBSZWRCbGFja1RyZWUucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJrZXlzXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oayx2KSB7XG4gICAgICByZXN1bHQucHVzaChrKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwidmFsdWVzXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oayx2KSB7XG4gICAgICByZXN1bHQucHVzaCh2KVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KVxuXG4vL1JldHVybnMgdGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImxlbmd0aFwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290Ll9jb3VudFxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG59KVxuXG4vL0luc2VydCBhIG5ldyBpdGVtIGludG8gdGhlIHRyZWVcbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgLy9GaW5kIHBvaW50IHRvIGluc2VydCBuZXcgbm9kZSBhdFxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgbl9zdGFjayA9IFtdXG4gIHZhciBkX3N0YWNrID0gW11cbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgbl9zdGFjay5wdXNoKG4pXG4gICAgZF9zdGFjay5wdXNoKGQpXG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIC8vUmVidWlsZCBwYXRoIHRvIGxlYWYgbm9kZVxuICBuX3N0YWNrLnB1c2gobmV3IFJCTm9kZShSRUQsIGtleSwgdmFsdWUsIG51bGwsIG51bGwsIDEpKVxuICBmb3IodmFyIHM9bl9zdGFjay5sZW5ndGgtMjsgcz49MDsgLS1zKSB7XG4gICAgdmFyIG4gPSBuX3N0YWNrW3NdXG4gICAgaWYoZF9zdGFja1tzXSA8PSAwKSB7XG4gICAgICBuX3N0YWNrW3NdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG5fc3RhY2tbcysxXSwgbi5yaWdodCwgbi5fY291bnQrMSlcbiAgICB9IGVsc2Uge1xuICAgICAgbl9zdGFja1tzXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBuLmxlZnQsIG5fc3RhY2tbcysxXSwgbi5fY291bnQrMSlcbiAgICB9XG4gIH1cbiAgLy9SZWJhbGFuY2UgdHJlZSB1c2luZyByb3RhdGlvbnNcbiAgLy9jb25zb2xlLmxvZyhcInN0YXJ0IGluc2VydFwiLCBrZXksIGRfc3RhY2spXG4gIGZvcih2YXIgcz1uX3N0YWNrLmxlbmd0aC0xOyBzPjE7IC0tcykge1xuICAgIHZhciBwID0gbl9zdGFja1tzLTFdXG4gICAgdmFyIG4gPSBuX3N0YWNrW3NdXG4gICAgaWYocC5fY29sb3IgPT09IEJMQUNLIHx8IG4uX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdmFyIHBwID0gbl9zdGFja1tzLTJdXG4gICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgaWYocC5sZWZ0ID09PSBuKSB7XG4gICAgICAgIHZhciB5ID0gcHAucmlnaHRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxMclwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5yaWdodCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxMYlwiKVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLmxlZnQgPSBwLnJpZ2h0XG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAucmlnaHQgPSBwcFxuICAgICAgICAgIG5fc3RhY2tbcy0yXSA9IHBcbiAgICAgICAgICBuX3N0YWNrW3MtMV0gPSBuXG4gICAgICAgICAgcmVjb3VudChwcClcbiAgICAgICAgICByZWNvdW50KHApXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAubGVmdCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gcHAucmlnaHRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxSclwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5yaWdodCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxSYlwiKVxuICAgICAgICAgIHAucmlnaHQgPSBuLmxlZnRcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBwcC5sZWZ0ID0gbi5yaWdodFxuICAgICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBuLmxlZnQgPSBwXG4gICAgICAgICAgbi5yaWdodCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gblxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IHBcbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICByZWNvdW50KG4pXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAubGVmdCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYocC5yaWdodCA9PT0gbikge1xuICAgICAgICB2YXIgeSA9IHBwLmxlZnRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJSclwiLCB5LmtleSlcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcHAubGVmdCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJSYlwiKVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLnJpZ2h0ID0gcC5sZWZ0XG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAubGVmdCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gcFxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IG5cbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICBpZihzID49IDMpIHtcbiAgICAgICAgICAgIHZhciBwcHAgPSBuX3N0YWNrW3MtM11cbiAgICAgICAgICAgIGlmKHBwcC5yaWdodCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLnJpZ2h0ID0gcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gcHAubGVmdFxuICAgICAgICBpZih5ICYmIHkuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkxyXCIpXG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHBwLmxlZnQgPSByZXBhaW50KEJMQUNLLCB5KVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHMgLT0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSTGJcIilcbiAgICAgICAgICBwLmxlZnQgPSBuLnJpZ2h0XG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcHAucmlnaHQgPSBuLmxlZnRcbiAgICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgbi5yaWdodCA9IHBcbiAgICAgICAgICBuLmxlZnQgPSBwcFxuICAgICAgICAgIG5fc3RhY2tbcy0yXSA9IG5cbiAgICAgICAgICBuX3N0YWNrW3MtMV0gPSBwXG4gICAgICAgICAgcmVjb3VudChwcClcbiAgICAgICAgICByZWNvdW50KHApXG4gICAgICAgICAgcmVjb3VudChuKVxuICAgICAgICAgIGlmKHMgPj0gMykge1xuICAgICAgICAgICAgdmFyIHBwcCA9IG5fc3RhY2tbcy0zXVxuICAgICAgICAgICAgaWYocHBwLnJpZ2h0ID09PSBwcCkge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAubGVmdCA9IG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL1JldHVybiBuZXcgdHJlZVxuICBuX3N0YWNrWzBdLl9jb2xvciA9IEJMQUNLXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKGNtcCwgbl9zdGFja1swXSlcbn1cblxuXG4vL1Zpc2l0IGFsbCBub2RlcyBpbm9yZGVyXG5mdW5jdGlvbiBkb1Zpc2l0RnVsbCh2aXNpdCwgbm9kZSkge1xuICBpZihub2RlLmxlZnQpIHtcbiAgICB2YXIgdiA9IGRvVmlzaXRGdWxsKHZpc2l0LCBub2RlLmxlZnQpXG4gICAgaWYodikgeyByZXR1cm4gdiB9XG4gIH1cbiAgdmFyIHYgPSB2aXNpdChub2RlLmtleSwgbm9kZS52YWx1ZSlcbiAgaWYodikgeyByZXR1cm4gdiB9XG4gIGlmKG5vZGUucmlnaHQpIHtcbiAgICByZXR1cm4gZG9WaXNpdEZ1bGwodmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuLy9WaXNpdCBoYWxmIG5vZGVzIGluIG9yZGVyXG5mdW5jdGlvbiBkb1Zpc2l0SGFsZihsbywgY29tcGFyZSwgdmlzaXQsIG5vZGUpIHtcbiAgdmFyIGwgPSBjb21wYXJlKGxvLCBub2RlLmtleSlcbiAgaWYobCA8PSAwKSB7XG4gICAgaWYobm9kZS5sZWZ0KSB7XG4gICAgICB2YXIgdiA9IGRvVmlzaXRIYWxmKGxvLCBjb21wYXJlLCB2aXNpdCwgbm9kZS5sZWZ0KVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICAgIHZhciB2ID0gdmlzaXQobm9kZS5rZXksIG5vZGUudmFsdWUpXG4gICAgaWYodikgeyByZXR1cm4gdiB9XG4gIH1cbiAgaWYobm9kZS5yaWdodCkge1xuICAgIHJldHVybiBkb1Zpc2l0SGFsZihsbywgY29tcGFyZSwgdmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuLy9WaXNpdCBhbGwgbm9kZXMgd2l0aGluIGEgcmFuZ2VcbmZ1bmN0aW9uIGRvVmlzaXQobG8sIGhpLCBjb21wYXJlLCB2aXNpdCwgbm9kZSkge1xuICB2YXIgbCA9IGNvbXBhcmUobG8sIG5vZGUua2V5KVxuICB2YXIgaCA9IGNvbXBhcmUoaGksIG5vZGUua2V5KVxuICB2YXIgdlxuICBpZihsIDw9IDApIHtcbiAgICBpZihub2RlLmxlZnQpIHtcbiAgICAgIHYgPSBkb1Zpc2l0KGxvLCBoaSwgY29tcGFyZSwgdmlzaXQsIG5vZGUubGVmdClcbiAgICAgIGlmKHYpIHsgcmV0dXJuIHYgfVxuICAgIH1cbiAgICBpZihoID4gMCkge1xuICAgICAgdiA9IHZpc2l0KG5vZGUua2V5LCBub2RlLnZhbHVlKVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICB9XG4gIGlmKGggPiAwICYmIG5vZGUucmlnaHQpIHtcbiAgICByZXR1cm4gZG9WaXNpdChsbywgaGksIGNvbXBhcmUsIHZpc2l0LCBub2RlLnJpZ2h0KVxuICB9XG59XG5cblxucHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIHJiVHJlZUZvckVhY2godmlzaXQsIGxvLCBoaSkge1xuICBpZighdGhpcy5yb290KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZG9WaXNpdEZ1bGwodmlzaXQsIHRoaXMucm9vdClcbiAgICBicmVha1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGRvVmlzaXRIYWxmKGxvLCB0aGlzLl9jb21wYXJlLCB2aXNpdCwgdGhpcy5yb290KVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIDM6XG4gICAgICBpZih0aGlzLl9jb21wYXJlKGxvLCBoaSkgPj0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb1Zpc2l0KGxvLCBoaSwgdGhpcy5fY29tcGFyZSwgdmlzaXQsIHRoaXMucm9vdClcbiAgICBicmVha1xuICB9XG59XG5cbi8vRmlyc3QgaXRlbSBpbiBsaXN0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwiYmVnaW5cIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IFtdXG4gICAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG4gIH1cbn0pXG5cbi8vTGFzdCBpdGVtIGluIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJlbmRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IFtdXG4gICAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICB9XG59KVxuXG4vL0ZpbmQgdGhlIGl0aCBpdGVtIGluIHRoZSB0cmVlXG5wcm90by5hdCA9IGZ1bmN0aW9uKGlkeCkge1xuICBpZihpZHggPCAwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbiAgfVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB3aGlsZSh0cnVlKSB7XG4gICAgc3RhY2sucHVzaChuKVxuICAgIGlmKG4ubGVmdCkge1xuICAgICAgaWYoaWR4IDwgbi5sZWZ0Ll9jb3VudCkge1xuICAgICAgICBuID0gbi5sZWZ0XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZHggLT0gbi5sZWZ0Ll9jb3VudFxuICAgIH1cbiAgICBpZighaWR4KSB7XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICAgIH1cbiAgICBpZHggLT0gMVxuICAgIGlmKG4ucmlnaHQpIHtcbiAgICAgIGlmKGlkeCA+PSBuLnJpZ2h0Ll9jb3VudCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbn1cblxucHJvdG8uZ2UgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8uZ3QgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA8IDApIHtcbiAgICAgIGxhc3RfcHRyID0gc3RhY2subGVuZ3RoXG4gICAgfVxuICAgIGlmKGQgPCAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHN0YWNrLmxlbmd0aCA9IGxhc3RfcHRyXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG59XG5cbnByb3RvLmx0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBjbXAgPSB0aGlzLl9jb21wYXJlXG4gIHZhciBuID0gdGhpcy5yb290XG4gIHZhciBzdGFjayA9IFtdXG4gIHZhciBsYXN0X3B0ciA9IDBcbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgc3RhY2sucHVzaChuKVxuICAgIGlmKGQgPiAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8ubGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA+PSAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDwgMCkge1xuICAgICAgbiA9IG4ubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfVxuICBzdGFjay5sZW5ndGggPSBsYXN0X3B0clxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxufVxuXG4vL0ZpbmRzIHRoZSBpdGVtIHdpdGgga2V5IGlmIGl0IGV4aXN0c1xucHJvdG8uZmluZCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbiAgICB9XG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgW10pXG59XG5cbi8vUmVtb3ZlcyBpdGVtIHdpdGgga2V5IGZyb20gdHJlZVxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBpdGVyID0gdGhpcy5maW5kKGtleSlcbiAgaWYoaXRlcikge1xuICAgIHJldHVybiBpdGVyLnJlbW92ZSgpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy9SZXR1cm5zIHRoZSBpdGVtIGF0IGBrZXlgXG5wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgaWYoZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG4udmFsdWVcbiAgICB9XG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVyblxufVxuXG4vL0l0ZXJhdG9yIGZvciByZWQgYmxhY2sgdHJlZVxuZnVuY3Rpb24gUmVkQmxhY2tUcmVlSXRlcmF0b3IodHJlZSwgc3RhY2spIHtcbiAgdGhpcy50cmVlID0gdHJlZVxuICB0aGlzLl9zdGFjayA9IHN0YWNrXG59XG5cbnZhciBpcHJvdG8gPSBSZWRCbGFja1RyZWVJdGVyYXRvci5wcm90b3R5cGVcblxuLy9UZXN0IGlmIGl0ZXJhdG9yIGlzIHZhbGlkXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcInZhbGlkXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2subGVuZ3RoID4gMFxuICB9XG59KVxuXG4vL05vZGUgb2YgdGhlIGl0ZXJhdG9yXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcIm5vZGVcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy9NYWtlcyBhIGNvcHkgb2YgYW4gaXRlcmF0b3Jcbmlwcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMudHJlZSwgdGhpcy5fc3RhY2suc2xpY2UoKSlcbn1cblxuLy9Td2FwcyB0d28gbm9kZXNcbmZ1bmN0aW9uIHN3YXBOb2RlKG4sIHYpIHtcbiAgbi5rZXkgPSB2LmtleVxuICBuLnZhbHVlID0gdi52YWx1ZVxuICBuLmxlZnQgPSB2LmxlZnRcbiAgbi5yaWdodCA9IHYucmlnaHRcbiAgbi5fY29sb3IgPSB2Ll9jb2xvclxuICBuLl9jb3VudCA9IHYuX2NvdW50XG59XG5cbi8vRml4IHVwIGEgZG91YmxlIGJsYWNrIG5vZGUgaW4gYSB0cmVlXG5mdW5jdGlvbiBmaXhEb3VibGVCbGFjayhzdGFjaykge1xuICB2YXIgbiwgcCwgcywgelxuICBmb3IodmFyIGk9c3RhY2subGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIG4gPSBzdGFja1tpXVxuICAgIGlmKGkgPT09IDApIHtcbiAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwidmlzaXQgbm9kZTpcIiwgbi5rZXksIGksIHN0YWNrW2ldLmtleSwgc3RhY2tbaS0xXS5rZXkpXG4gICAgcCA9IHN0YWNrW2ktMV1cbiAgICBpZihwLmxlZnQgPT09IG4pIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJsZWZ0IGNoaWxkXCIpXG4gICAgICBzID0gcC5yaWdodFxuICAgICAgaWYocy5yaWdodCAmJiBzLnJpZ2h0Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDE6IHJpZ2h0IHNpYmxpbmcgY2hpbGQgcmVkXCIpXG4gICAgICAgIHMgPSBwLnJpZ2h0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLnJpZ2h0ID0gY2xvbmVOb2RlKHMucmlnaHQpXG4gICAgICAgIHAucmlnaHQgPSBzLmxlZnRcbiAgICAgICAgcy5sZWZ0ID0gcFxuICAgICAgICBzLnJpZ2h0ID0gelxuICAgICAgICBzLl9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICB6Ll9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICBpZihpID4gMSkge1xuICAgICAgICAgIHZhciBwcCA9IHN0YWNrW2ktMl1cbiAgICAgICAgICBpZihwcC5sZWZ0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHNcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgaWYocy5sZWZ0ICYmIHMubGVmdC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiBsZWZ0IHNpYmxpbmcgY2hpbGQgcmVkXCIpXG4gICAgICAgIHMgPSBwLnJpZ2h0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLmxlZnQgPSBjbG9uZU5vZGUocy5sZWZ0KVxuICAgICAgICBwLnJpZ2h0ID0gei5sZWZ0XG4gICAgICAgIHMubGVmdCA9IHoucmlnaHRcbiAgICAgICAgei5sZWZ0ID0gcFxuICAgICAgICB6LnJpZ2h0ID0gc1xuICAgICAgICB6Ll9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcy5fY29sb3IgPSBCTEFDS1xuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICByZWNvdW50KHopXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLmxlZnQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLmxlZnQgPSB6XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gelxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gelxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmKHMuX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgICBpZihwLl9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgcmVkIHBhcmVudFwiLCBwLnJpZ2h0LnZhbHVlKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwLnJpZ2h0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgYmxhY2sgcGFyZW50XCIsIHAucmlnaHQudmFsdWUpXG4gICAgICAgICAgcC5yaWdodCA9IHJlcGFpbnQoUkVELCBzKVxuICAgICAgICAgIGNvbnRpbnVlICBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMzogcmVkIHNpYmxpbmdcIilcbiAgICAgICAgcyA9IGNsb25lTm9kZShzKVxuICAgICAgICBwLnJpZ2h0ID0gcy5sZWZ0XG4gICAgICAgIHMubGVmdCA9IHBcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBwLl9jb2xvciA9IFJFRFxuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgICAgICAgcHAubGVmdCA9IHNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAucmlnaHQgPSBzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrW2ktMV0gPSBzXG4gICAgICAgIHN0YWNrW2ldID0gcFxuICAgICAgICBpZihpKzEgPCBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBzdGFja1tpKzFdID0gblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgICAgfVxuICAgICAgICBpID0gaSsyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJyaWdodCBjaGlsZFwiKVxuICAgICAgcyA9IHAubGVmdFxuICAgICAgaWYocy5sZWZ0ICYmIHMubGVmdC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiBsZWZ0IHNpYmxpbmcgY2hpbGQgcmVkXCIsIHAudmFsdWUsIHAuX2NvbG9yKVxuICAgICAgICBzID0gcC5sZWZ0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLmxlZnQgPSBjbG9uZU5vZGUocy5sZWZ0KVxuICAgICAgICBwLmxlZnQgPSBzLnJpZ2h0XG4gICAgICAgIHMucmlnaHQgPSBwXG4gICAgICAgIHMubGVmdCA9IHpcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgei5fY29sb3IgPSBCTEFDS1xuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSBpZihzLnJpZ2h0ICYmIHMucmlnaHQuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMTogcmlnaHQgc2libGluZyBjaGlsZCByZWRcIilcbiAgICAgICAgcyA9IHAubGVmdCA9IGNsb25lTm9kZShzKVxuICAgICAgICB6ID0gcy5yaWdodCA9IGNsb25lTm9kZShzLnJpZ2h0KVxuICAgICAgICBwLmxlZnQgPSB6LnJpZ2h0XG4gICAgICAgIHMucmlnaHQgPSB6LmxlZnRcbiAgICAgICAgei5yaWdodCA9IHBcbiAgICAgICAgei5sZWZ0ID0gc1xuICAgICAgICB6Ll9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcy5fY29sb3IgPSBCTEFDS1xuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICByZWNvdW50KHopXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLnJpZ2h0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHpcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAubGVmdCA9IHpcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHpcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZihzLl9jb2xvciA9PT0gQkxBQ0spIHtcbiAgICAgICAgaWYocC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDI6IGJsYWNrIHNpYmxpbmcsIHJlZCBwYXJlbnRcIilcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcC5sZWZ0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgYmxhY2sgcGFyZW50XCIpXG4gICAgICAgICAgcC5sZWZ0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgY29udGludWUgIFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAzOiByZWQgc2libGluZ1wiKVxuICAgICAgICBzID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHAubGVmdCA9IHMucmlnaHRcbiAgICAgICAgcy5yaWdodCA9IHBcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBwLl9jb2xvciA9IFJFRFxuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICBzdGFja1tpXSA9IHBcbiAgICAgICAgaWYoaSsxIDwgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgc3RhY2tbaSsxXSA9IG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKG4pXG4gICAgICAgIH1cbiAgICAgICAgaSA9IGkrMlxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1JlbW92ZXMgaXRlbSBhdCBpdGVyYXRvciBmcm9tIHRyZWVcbmlwcm90by5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZVxuICB9XG4gIC8vRmlyc3QgY29weSBwYXRoIHRvIG5vZGVcbiAgdmFyIGNzdGFjayA9IG5ldyBBcnJheShzdGFjay5sZW5ndGgpXG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGNzdGFja1tjc3RhY2subGVuZ3RoLTFdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgbi5yaWdodCwgbi5fY291bnQpXG4gIGZvcih2YXIgaT1zdGFjay5sZW5ndGgtMjsgaT49MDsgLS1pKSB7XG4gICAgdmFyIG4gPSBzdGFja1tpXVxuICAgIGlmKG4ubGVmdCA9PT0gc3RhY2tbaSsxXSkge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIGNzdGFja1tpKzFdLCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgfVxuXG4gIC8vR2V0IG5vZGVcbiAgbiA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTFdXG4gIC8vY29uc29sZS5sb2coXCJzdGFydCByZW1vdmU6IFwiLCBuLnZhbHVlKVxuXG4gIC8vSWYgbm90IGxlYWYsIHRoZW4gc3dhcCB3aXRoIHByZXZpb3VzIG5vZGVcbiAgaWYobi5sZWZ0ICYmIG4ucmlnaHQpIHtcbiAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIHRvIGxlYWZcIilcblxuICAgIC8vRmlyc3Qgd2FsayB0byBwcmV2aW91cyBsZWFmXG4gICAgdmFyIHNwbGl0ID0gY3N0YWNrLmxlbmd0aFxuICAgIG4gPSBuLmxlZnRcbiAgICB3aGlsZShuLnJpZ2h0KSB7XG4gICAgICBjc3RhY2sucHVzaChuKVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgLy9Db3B5IHBhdGggdG8gbGVhZlxuICAgIHZhciB2ID0gY3N0YWNrW3NwbGl0LTFdXG4gICAgY3N0YWNrLnB1c2gobmV3IFJCTm9kZShuLl9jb2xvciwgdi5rZXksIHYudmFsdWUsIG4ubGVmdCwgbi5yaWdodCwgbi5fY291bnQpKVxuICAgIGNzdGFja1tzcGxpdC0xXS5rZXkgPSBuLmtleVxuICAgIGNzdGFja1tzcGxpdC0xXS52YWx1ZSA9IG4udmFsdWVcblxuICAgIC8vRml4IHVwIHN0YWNrXG4gICAgZm9yKHZhciBpPWNzdGFjay5sZW5ndGgtMjsgaT49c3BsaXQ7IC0taSkge1xuICAgICAgbiA9IGNzdGFja1tpXVxuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgICBjc3RhY2tbc3BsaXQtMV0ubGVmdCA9IGNzdGFja1tzcGxpdF1cbiAgfVxuICAvL2NvbnNvbGUubG9nKFwic3RhY2s9XCIsIGNzdGFjay5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi52YWx1ZSB9KSlcblxuICAvL1JlbW92ZSBsZWFmIG5vZGVcbiAgbiA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4uX2NvbG9yID09PSBSRUQpIHtcbiAgICAvL0Vhc3kgY2FzZTogcmVtb3ZpbmcgcmVkIGxlYWZcbiAgICAvL2NvbnNvbGUubG9nKFwiUkVEIGxlYWZcIilcbiAgICB2YXIgcCA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTJdXG4gICAgaWYocC5sZWZ0ID09PSBuKSB7XG4gICAgICBwLmxlZnQgPSBudWxsXG4gICAgfSBlbHNlIGlmKHAucmlnaHQgPT09IG4pIHtcbiAgICAgIHAucmlnaHQgPSBudWxsXG4gICAgfVxuICAgIGNzdGFjay5wb3AoKVxuICAgIGZvcih2YXIgaT0wOyBpPGNzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKHRoaXMudHJlZS5fY29tcGFyZSwgY3N0YWNrWzBdKVxuICB9IGVsc2Uge1xuICAgIGlmKG4ubGVmdCB8fCBuLnJpZ2h0KSB7XG4gICAgICAvL1NlY29uZCBlYXN5IGNhc2U6ICBTaW5nbGUgY2hpbGQgYmxhY2sgcGFyZW50XG4gICAgICAvL2NvbnNvbGUubG9nKFwiQkxBQ0sgc2luZ2xlIGNoaWxkXCIpXG4gICAgICBpZihuLmxlZnQpIHtcbiAgICAgICAgc3dhcE5vZGUobiwgbi5sZWZ0KVxuICAgICAgfSBlbHNlIGlmKG4ucmlnaHQpIHtcbiAgICAgICAgc3dhcE5vZGUobiwgbi5yaWdodClcbiAgICAgIH1cbiAgICAgIC8vQ2hpbGQgbXVzdCBiZSByZWQsIHNvIHJlcGFpbnQgaXQgYmxhY2sgdG8gYmFsYW5jZSBjb2xvclxuICAgICAgbi5fY29sb3IgPSBCTEFDS1xuICAgICAgZm9yKHZhciBpPTA7IGk8Y3N0YWNrLmxlbmd0aC0xOyArK2kpIHtcbiAgICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIGNzdGFja1swXSlcbiAgICB9IGVsc2UgaWYoY3N0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy9UaGlyZCBlYXN5IGNhc2U6IHJvb3RcbiAgICAgIC8vY29uc29sZS5sb2coXCJST09UXCIpXG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vSGFyZCBjYXNlOiBSZXBhaW50IG4sIGFuZCB0aGVuIGRvIHNvbWUgbmFzdHkgc3R1ZmZcbiAgICAgIC8vY29uc29sZS5sb2coXCJCTEFDSyBsZWFmIG5vIGNoaWxkcmVuXCIpXG4gICAgICBmb3IodmFyIGk9MDsgaTxjc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gY3N0YWNrW2NzdGFjay5sZW5ndGgtMl1cbiAgICAgIGZpeERvdWJsZUJsYWNrKGNzdGFjaylcbiAgICAgIC8vRml4IHVwIGxpbmtzXG4gICAgICBpZihwYXJlbnQubGVmdCA9PT0gbikge1xuICAgICAgICBwYXJlbnQubGVmdCA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5yaWdodCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG59XG5cbi8vUmV0dXJucyBrZXlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwia2V5XCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdLmtleVxuICAgIH1cbiAgICByZXR1cm5cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy9SZXR1cm5zIHZhbHVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcInZhbHVlXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdLnZhbHVlXG4gICAgfVxuICAgIHJldHVyblxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5cbi8vUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhpcyBpdGVyYXRvciBpbiB0aGUgc29ydGVkIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaW5kZXhcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHggPSAwXG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciByID0gdGhpcy50cmVlLnJvb3RcbiAgICAgIGlmKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuX2NvdW50XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCkge1xuICAgICAgaWR4ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdLmxlZnQuX2NvdW50XG4gICAgfVxuICAgIGZvcih2YXIgcz1zdGFjay5sZW5ndGgtMjsgcz49MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzKzFdID09PSBzdGFja1tzXS5yaWdodCkge1xuICAgICAgICArK2lkeFxuICAgICAgICBpZihzdGFja1tzXS5sZWZ0KSB7XG4gICAgICAgICAgaWR4ICs9IHN0YWNrW3NdLmxlZnQuX2NvdW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeFxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vL0FkdmFuY2VzIGl0ZXJhdG9yIHRvIG5leHQgZWxlbWVudCBpbiBsaXN0XG5pcHJvdG8ubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1xuICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICBpZihuLnJpZ2h0KSB7XG4gICAgbiA9IG4ucmlnaHRcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YWNrLnBvcCgpXG4gICAgd2hpbGUoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGgtMV0ucmlnaHQgPT09IG4pIHtcbiAgICAgIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuICB9XG59XG5cbi8vQ2hlY2tzIGlmIGl0ZXJhdG9yIGlzIGF0IGVuZCBvZiB0cmVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcImhhc05leHRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gICAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYoc3RhY2tbc3RhY2subGVuZ3RoLTFdLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IodmFyIHM9c3RhY2subGVuZ3RoLTE7IHM+MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzLTFdLmxlZnQgPT09IHN0YWNrW3NdKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59KVxuXG4vL1VwZGF0ZSB2YWx1ZVxuaXByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVwZGF0ZSBlbXB0eSBub2RlIVwiKVxuICB9XG4gIHZhciBjc3RhY2sgPSBuZXcgQXJyYXkoc3RhY2subGVuZ3RoKVxuICB2YXIgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICBjc3RhY2tbY3N0YWNrLmxlbmd0aC0xXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCB2YWx1ZSwgbi5sZWZ0LCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgZm9yKHZhciBpPXN0YWNrLmxlbmd0aC0yOyBpPj0wOyAtLWkpIHtcbiAgICBuID0gc3RhY2tbaV1cbiAgICBpZihuLmxlZnQgPT09IHN0YWNrW2krMV0pIHtcbiAgICAgIGNzdGFja1tpXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBjc3RhY2tbaSsxXSwgbi5yaWdodCwgbi5fY291bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzdGFja1tpXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBuLmxlZnQsIGNzdGFja1tpKzFdLCBuLl9jb3VudClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG59XG5cbi8vTW92ZXMgaXRlcmF0b3IgYmFja3dhcmQgb25lIGVsZW1lbnRcbmlwcm90by5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4ubGVmdCkge1xuICAgIG4gPSBuLmxlZnRcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wb3AoKVxuICAgIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoLTFdLmxlZnQgPT09IG4pIHtcbiAgICAgIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuICB9XG59XG5cbi8vQ2hlY2tzIGlmIGl0ZXJhdG9yIGlzIGF0IHN0YXJ0IG9mIHRyZWVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaGFzUHJldlwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZm9yKHZhciBzPXN0YWNrLmxlbmd0aC0xOyBzPjA7IC0tcykge1xuICAgICAgaWYoc3RhY2tbcy0xXS5yaWdodCA9PT0gc3RhY2tbc10pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pXG5cbi8vRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIGlmKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vQnVpbGQgYSB0cmVlXG5mdW5jdGlvbiBjcmVhdGVSQlRyZWUoY29tcGFyZSkge1xuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZShjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlLCBudWxsKVxufSJdfQ==

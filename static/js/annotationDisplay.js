// Generated by CoffeeScript 1.11.1
var AnnotationDisplay, colours, lastColourUsed,
  slice = [].slice;

colours = [[31, 119, 180], [174, 199, 232], [255, 127, 14], [255, 187, 120], [44, 160, 44], [152, 223, 138], [214, 39, 40], [255, 152, 150], [148, 103, 189], [197, 176, 213], [140, 86, 75], [196, 156, 148], [227, 119, 194], [247, 182, 210], [127, 127, 127], [199, 199, 199], [188, 189, 34], [219, 219, 141], [23, 190, 207], [158, 218, 229]];

lastColourUsed = 0;

AnnotationDisplay = (function() {

  /*
    Encapsulates the generation of the required DOM objects to show overlapping annotations
   */
  function AnnotationDisplay(target) {
    this.target = target;
    this.colourField = [];
    this.annotationsAt = [];
    this.viewer = null;
    this.typeColours = {};
    this.spans = [];
  }

  AnnotationDisplay.prototype.setDocument = function(text1, annotationSets) {
    var i, j, ref, ref1, results, results1;
    this.text = text1;
    this.annotationSets = annotationSets;
    this.colourField = (function() {
      results = [];
      for (var i = 0, ref = this.text.length; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map(function() {
      return [255, 255, 255, 1];
    });
    this.annotationsAt = (function() {
      results1 = [];
      for (var j = 0, ref1 = this.text.length; 0 <= ref1 ? j <= ref1 : j >= ref1; 0 <= ref1 ? j++ : j--){ results1.push(j); }
      return results1;
    }).apply(this).map(function() {
      return {};
    });
    this.typeColours = {};
    return this.setAnnotations(this.annotationSets);
  };

  AnnotationDisplay.prototype.setAnnotations = function(annotationSets) {
    this.annotationSets = annotationSets;
    this.updateColourField();
    this.spans = this.generateSpansInRange();
    this.spans = this.renderSpans(this.spans, this.text);
    return this.update();
  };

  AnnotationDisplay.prototype.getTypeColour = function(type, alpha) {
    var colour;
    if (alpha == null) {
      alpha = 0.3;
    }

    /* 
      Generates a colour for the given type, or retrieves it if there already is one.
     */
    if (this.typeColours.hasOwnProperty(type)) {
      return slice.call(this.typeColours[type]).concat([alpha]);
    } else {
      colour = colours[lastColourUsed];
      lastColourUsed += 1;
      if (lastColourUsed === colours.length) {
        lastColourUsed = 0;
      }
      this.typeColours[type] = colour;
      return slice.call(colour).concat([alpha]);
    }
  };

  AnnotationDisplay.prototype.combineAlpha = function(a, b) {

    /* Combines two colours, appying alpha channel */
    var alpha, c, i, len, out, ref;
    out = [0, 0, 0, 0];
    alpha = a[3] + b[3] * (1 - a[3]);
    out[3] = alpha;
    ref = [0, 1, 2];
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      out[c] = Math.floor((a[c] * a[3] + b[c] * b[3] * (1 - a[3])) / alpha);
    }
    return out;
  };

  AnnotationDisplay.prototype.updateColourField = function(start, end) {
    var annotation, annotations, i, index, j, offset, ref, ref1, ref2, results, results1, results2, type, typeColour;
    if (start == null) {
      start = null;
    }
    if (end == null) {
      end = null;
    }
    this.colourField = (function() {
      results = [];
      for (var i = 0, ref = this.text.length; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map(function() {
      return [255, 255, 255, 0];
    });
    this.annotationsAt = (function() {
      results1 = [];
      for (var j = 0, ref1 = this.text.length; 0 <= ref1 ? j <= ref1 : j >= ref1; 0 <= ref1 ? j++ : j--){ results1.push(j); }
      return results1;
    }).apply(this).map(function() {
      return {};
    });

    /* Calculates the colours at each offset in the document */
    ref2 = this.annotationSets;
    results2 = [];
    for (type in ref2) {
      annotations = ref2[type];
      typeColour = this.getTypeColour(type);
      results2.push((function() {
        var results3;
        results3 = [];
        for (index in annotations) {
          annotation = annotations[index];
          annotation.type = type;
          results3.push((function() {
            var k, ref3, ref4, results4;
            results4 = [];
            for (offset = k = ref3 = annotation.indices[0], ref4 = annotation.indices[1]; ref3 <= ref4 ? k <= ref4 : k >= ref4; offset = ref3 <= ref4 ? ++k : --k) {
              this.colourField[offset] = this.combineAlpha(typeColour, this.colourField[offset]);
              results4.push(this.annotationsAt[offset][annotation.annotationID] = annotation);
            }
            return results4;
          }).call(this));
        }
        return results3;
      }).call(this));
    }
    return results2;
  };

  AnnotationDisplay.prototype.invalidate = function(left, right) {
    var new_spans, old_spans, ref, span, span_range;
    this.updateColourField(left, right);
    span_range = this.findSpanRange(left, right);
    new_spans = this.renderSpans(this.generateSpansInRange(this.spans[span_range[0]].start, this.spans[span_range[1]].end));
    old_spans = this.spans.slice(span_range[0], +span_range[1] + 1 || 9e9);
    [].splice.apply(this.spans, [(ref = span_range[0]), span_range[1] - ref + 1].concat(new_spans)), new_spans;
    new_spans = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = new_spans.length; i < len; i++) {
        span = new_spans[i];
        results.push(span.node);
      }
      return results;
    })();
    old_spans = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = old_spans.length; i < len; i++) {
        span = old_spans[i];
        results.push(span.node);
      }
      return results;
    })();
    $(old_spans).first().before(new_spans);
    return $(old_spans).remove();
  };

  AnnotationDisplay.prototype.generateSpansInRange = function(start, end) {
    var annotations, colour, i, lastAnnotations, lastColour, lastOffset, offset, ref, ref1, spans;
    if (start == null) {
      start = null;
    }
    if (end == null) {
      end = null;
    }

    /* Returns the ranges for each colour area */
    start = start === null ? 0 : start;
    end = end === null ? this.colourField.length - 1 : end;
    lastOffset = start;
    lastColour = this.colourField[lastOffset];
    lastAnnotations = this.annotationsAt[lastOffset];
    spans = [];
    for (offset = i = ref = start, ref1 = end; ref <= ref1 ? i <= ref1 : i >= ref1; offset = ref <= ref1 ? ++i : --i) {
      colour = this.colourField[offset];
      annotations = this.annotationsAt[offset];
      if (!Object.equal(lastAnnotations, annotations)) {
        spans.push({
          start: lastOffset,
          end: offset - 1,
          colour: lastColour,
          annotations: lastAnnotations
        });
        lastColour = colour;
        lastOffset = offset;
        lastAnnotations = this.annotationsAt[offset];
      }
    }
    spans.push({
      start: lastOffset,
      end: end,
      colour: lastColour,
      annotations: this.annotationsAt[end - 1]
    });
    return spans;
  };

  AnnotationDisplay.prototype.findSpanRange = function(start, end) {

    /* Performs a search to find the spans that are within the given range */
    var left, mid, right;
    if (this.spans === []) {
      return [];
    }
    left = 0;
    right = this.spans.length - 1;
    mid = Math.floor((left + right) / 2);
    while (!(this.spans[mid].start >= start && this.spans[mid].start <= end) && left <= right) {
      if (this.spans[mid].start < start) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
      mid = Math.floor((left + right) / 2);
    }
    left = mid;
    right = mid;
    while ((left > 0) && (this.spans[left - 1].end >= start)) {
      left -= 1;
    }
    while ((right < this.spans.length - 1) && (this.spans[right + 1].start <= end)) {
      right += 1;
    }
    return [left, right];
  };

  AnnotationDisplay.prototype.addNewLines = function(text) {
    return text.split("\n").join("<br>");
  };

  AnnotationDisplay.prototype.makeColourString = function(colour) {
    return "rgba(" + (Math.floor(colour[0])) + ", " + (Math.floor(colour[1])) + ", " + (Math.floor(colour[2])) + ", " + colour[3] + ")";
  };

  AnnotationDisplay.prototype.renderSpans = function(spans) {

    /* Converts the specified spans to nodes in the document
    
    Returns a copy of the spans with the nodes attached as a field
     */
    var colour, i, len, result, span, spanNode, text, textNodes;
    result = [];
    for (i = 0, len = spans.length; i < len; i++) {
      span = spans[i];
      text = this.text.slice(span.start, +span.end + 1 || 9e9);
      textNodes = $.parseHTML(this.addNewLines(text));
      spanNode = $("<span data-offset='" + span.start + "'>").append(textNodes).get(0);
      colour = span.colour;
      if (colour !== null) {
        spanNode.style["background-color"] = this.makeColourString(colour);
      }
      span = $.extend({}, span, {
        node: spanNode
      });
      this.attachEvents(span);
      result.push(span);
    }
    return result;
  };

  AnnotationDisplay.prototype.attachEvents = function(span) {
    $(span.node).on("mouseover", null, span, (function(_this) {
      return function(event) {
        return _this.showSpan(event.data);
      };
    })(this));
    return $(span.node).on("click", null, span, (function(_this) {
      return function(event) {
        var annotation, annotationId, ref, results;
        ref = span.annotations;
        results = [];
        for (annotationId in ref) {
          annotation = ref[annotationId];
          _this.viewer.showAnnotation(annotation);
          break;
        }
        return results;
      };
    })(this));
  };

  AnnotationDisplay.prototype.showSpan = function(span) {
    var annotation, annotationId, ref, text;
    text = "";
    ref = span.annotations;
    for (annotationId in ref) {
      annotation = ref[annotationId];
      text += annotation.type + "<br />";
    }
    return $("#annotationInfo").html(text);
  };

  AnnotationDisplay.prototype.deleteSpan = function(span) {
    var annotation, annotationId, ref, results;
    ref = span.annotations;
    results = [];
    for (annotationId in ref) {
      annotation = ref[annotationId];
      this.removeAnnotation(annotation);
      break;
    }
    return results;
  };

  AnnotationDisplay.prototype.update = function() {
    var nodes, span;
    nodes = (function() {
      var i, len, ref, results;
      ref = this.spans;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        span = ref[i];
        results.push(span.node);
      }
      return results;
    }).call(this);
    this.target.empty();
    return this.target.append(nodes);
  };

  AnnotationDisplay.prototype.removeAnnotation = function(annotation) {
    var left, right;
    this.annotationSets[annotation.type] = this.annotationSets[annotation.type].filter(function(ann) {
      return ann !== annotation;
    });
    left = annotation.indices[0];
    right = annotation.indices[1];
    return this.invalidate(left, right);
  };

  return AnnotationDisplay;

})();

//# sourceMappingURL=annotationDisplay.js.map
